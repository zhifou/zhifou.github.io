[{"id":0,"title":"","content":"","routePath":"/404","lang":"","toc":[],"domain":"","frontmatter":{"pageType":404},"version":""},{"id":1,"title":"我就是我，不一样的烟火","content":"#","routePath":"/about/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"归档","content":"","routePath":"/blog/archives","lang":"","toc":[],"domain":"","frontmatter":{"layout":"archives","title":"归档"},"version":""},{"id":3,"title":"分类","content":"","routePath":"/blog/categories","lang":"","toc":[],"domain":"","frontmatter":{"layout":"categories","title":"分类"},"version":""},{"id":4,"title":"友情链接","content":"#\n\n欢迎光顾我的小站。如果你也想和我交换友链，可以在下方留言。\n\n * 知否知否","routePath":"/blog/flinks","lang":"","toc":[],"domain":"","frontmatter":{"pageType":"doc","title":"友情链接","sidebar":false,"outline":false},"version":""},{"id":5,"title":"标签","content":"","routePath":"/blog/tags","lang":"","toc":[],"domain":"","frontmatter":{"layout":"tags","title":"标签"},"version":""},{"id":6,"title":"引导页","content":"#\n\nTIP\n\n博客还在基于Rspress优化中，敬请期待","routePath":"/guide/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"首页","content":"","routePath":"/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"home","title":"首页"},"version":""},{"id":8,"title":"软件与GPU光栅化","content":"原文：https://software.intel.com/content/www/us/en/develop/articles/software-vs-gpu\n-rasterization-in-chromium.html\n\n已发布：02/05/2016 最后更新时间：02/04/2016\n\n本文概述了web浏览器将网站信息光栅化为实际像素的方法。当web浏览器下载一个页面时，它解析源代码并创建DOM。然后它需要弄清楚哪些图像/文本/帧显示在哪里。该\n信息在内部表示为层树。您可以将层树视为简化的DOM树，因为它们只包含页面的可见元素，并且可以将一些DOM元素组合到一个层中。\n\n假设您已经有了图层树，并且希望在屏幕上显示它们。到目前为止，每个层都已经包含了有关如何绘制的信息，因此您只需要按正确的顺序调用正确的绘制说明。但是，每次用户滚动\n或播放动画时，必须对整个页面执行此操作，这显然是低效的。因此，我们将页面划分为多个平铺，这些平铺由大小约为256x256像素的正方形组成。[1]您可以在下图中看\n到平铺，并使用Chromium*开发工具将平铺边界可视化。[2]\n\n\n\n光栅化单个平铺比光栅化整个站点更容易，因为我们可以忽略在受影响的平铺上看不到的绘制命令。如果用户单击平铺或播放某些动画，则只需再次光栅化受影响的平铺。在简单的网\n页上，平铺通常只光栅化一次，但更多的交互式网站或带有动画的网站可能会导致每帧重新计算一些平铺。\n\n有两种主要的方法来光栅化一个平铺，旧的方法是做在它的CPU上，并把它作为一个纹理发送到GPU；较新的方法是使用GPU和OpenGL对其进行光栅化。每种方法都有各\n自的优缺点，每种方法都最适合某些类型的网页。GPU光栅化不会很快取代软件（CPU）光栅化，我稍后解释。\n\n\n软件（CPU）光栅化#\n\nChromium使用Skia库进行光栅化，最终使用扫描线算法创建位图。通常，要将结果发送到GPU并在屏幕上绘制，我们可以通过调用glTexImage2D（）将其\n上传，但Chromium的安全模型使其更加复杂。\n\n由于渲染过程是沙盒式的，无法直接访问GPU，Chromium使用一个单独的GPU进程，其主要目的是充当渲染过程和GPU之间的代理，接受OpenGL命令并将其传递\n给图形驱动程序。因此，我们必须将光栅化结果放入共享内存中，并向Chromium GPU进程发送一条消息，以便对其调用glTexImage2D（）。\n\n这有一个明显的缺点，在平铺的变化时，上传必须每次都做，这意味着大量的数据必须传输和GPU进程可以保持非常繁忙。简单的web页面不会受到这种影响，但是使用大量动画\n或JavaScript效果的交互式web页面几乎每帧都必须重新绘制（每秒最多60次）。这在移动设备上尤其是一个问题，因为屏幕更小，设计师通常在用户请求之前隐藏元\n素，这会产生许多过渡效果。\n\n\n零拷贝软件光栅化#\n\n零拷贝纹理上传是我的同事Dongseong Hwang和Tiago\nVignatti所做的优化。它试图最大限度地减少上传纹理到GPU的每一个平铺变化效率低下的过程。光栅化的方式与以前相同，但是我们没有为每个平铺更改使用glTex\nImage2D（）手动上载纹理，而是告诉GPU内存映射纹理在主内存中的位置，这样GPU就可以直接读取纹理。这样，ChromiumGPU进程只需进行初始内存映射设\n置，之后就可以保持空闲。这提高了性能，节省了移动设备的大量电池寿命。\n\n\nGPU光栅化#\n\n通过GPU光栅化，部分工作负载从CPU移动到GPU，所有多边形都必须使用OpenGL基本体（三角形和线）进行渲染。这也是由Skia通过GPU后端Skia\nGanesh执行的。结果永远不会保存在主内存中，因此不必复制到任何地方，因为这一切都发生在GPU上。虽然这稍微减少了主内存的使用，但它将使用更大数量的GPU内存\n。\n\nGPU光栅化的主要问题是字体或其他小而复杂的形状。OpenGL没有任何原生的文本呈现原语，因此您必须使用现有的库（或者痛苦地实现自己的库），该库可以使用各种方法\n对它们进行光栅化。例如，使用三角形表示角色、使用预计算的纹理或其他机制。在拥有高效算法的同时，让字体看起来很好并不是件小事。试着想象一下你需要多少个三角形来画一\n堵小小的中文墙。\n\n为什么我们不复制之前使用的光栅化算法，然后粘贴到GPU着色器中呢？在CPU上使用的扫描线算法是非常线性的，并且依赖于以前的结果，这使得它很难并行化。虽然GPU在\n技术上可以运行它，但这样做将完全消除使用GPU的优势，因为GPU非常擅长运行数千个独立的并行任务，但却非常不擅长运行单个任务。\n\n我们可以预先计算单个字符并将它们放入一个纹理中，基本上创建一个字体图集，如下图所示，而不是用三角形渲染文本。这个纹理然后被上传到GPU，它的片段被映射到由两个三\n角形组成的正方形上。然而，这仍然不能解决中文文本的问题，因为几乎所有的文字都有不同的字符。纹理最终将是巨大的，这消除了我们使用GPU的优势，否则就不必传输大量数\n据。Chromium*所做的是为每个网页创建一个新的字体图集，尽管这有其自身的缺点，但如果用户放大，则必须再次进行光栅化，否则字体会显得模糊。\n\n\n\n\n结论#\n\n虽然使用GPU来加速所有web页面的呈现会很好，但它并不适合某些任务。在Chromium中解决这个问题的计划是使用带有零拷贝优化的软件（CPU）渲染方法来优化那\n些速度更快的页面，但在其他情况下使用GPU渲染。我们可以通过一些启发式的方法来决定应该使用哪种方法。例如，如果站点有大量文本（特别是中文或阿拉伯语），我们可以使\n用CPU，并且在具有许多动画和过渡效果的页面上使用GPU。对于使用它有意义的情况，GPU加速渲染允许更无缝的动画和更好的性能。\n\n[1]. 这是一种简化。平铺不必是正方形，有时可以重叠，甚至在某些动画中移动。平铺通常与层树的结构无关，但有时层可以获得自己的平铺，例如当动画在屏幕上移动时。\n\n*其他名称和品牌可被视为他人的财产。\n\n[2]. 要查看任何页面的可视化效果，请打开Chromium dev\ntools（Ctrl+Shift+I），显示控制台（按Esc），查看底部的选项卡，然后打开“Rendering”。从那里，检查“显示合成层边界。”","routePath":"/2024/03/03/chrome-software-vs-gpu-rasterization/","lang":"","toc":[{"text":"软件（CPU）光栅化","id":"软件cpu光栅化","depth":3,"charIndex":755},{"text":"零拷贝软件光栅化","id":"零拷贝软件光栅化","depth":3,"charIndex":1209},{"text":"GPU光栅化","id":"gpu光栅化","depth":3,"charIndex":1453},{"text":"结论","id":"结论","depth":3,"charIndex":2179}],"domain":"","frontmatter":{"layout":"post","title":"软件与GPU光栅化","date":"2024-03-03T08:30:00.000Z","categories":["浏览器"],"tags":["chrome","GPU"]},"version":""},{"id":9,"title":"Linux常用命令","content":"> 作为一名前端开发者，熟悉linux命令是必备的，接下来我们了解一下，我们再开发过程中经常用到的linux常用命令都有哪些？如果谁想了解一下linux系统介绍\n> 可以看看百度百科。 —— 百度百科\n\n\nls 命令#\n\nls 命令是用于列表显示目录内的文件及目录：\n\n * ls -l 以长格式显示文件和目录的列表；\n * ll 在mac下可以直接使用这个，功能和ls -l相同\n * ls -a 显示所有子目录和文件的信息-A 与-a基本类似，但有两个特殊的隐藏目录‘.’和'..'不显示；\n\n\nmkdir 命令#\n\nmkdir 命令是用于创建目录的命令：\n\n * mkdir abcstatic 创建一个名为abcstatic的目录；\n\n\ncp 命令#\n\ncp 命令是用于复制文件或目录-f 覆盖同名文件或目录，强制复制-i 提醒用户确认-r 递归复制：\n\n * cp nginx.conf nginx-new.conf 复制单个文件到当前目录并命名；\n * cp -r vue-typescript ../typescript 复制某个目录包括里面的内容复制到上一层的typescript目录下；\n\n\nscp 命令#\n\nscp 命令是 secure copy 的缩写, scp 是 linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令。用于 Linux\n服务器之间复制文件和目录：\n\n * scp /home/work/music/1.mp3 root@192.168.10.123:/home/work/others/music\n   从本地复制到远程，指定了用户名，命令执行后需要再输入密码，仅指定了远程的目录，文件名字不变；\n * scp -r local_folder remote_username@remote_ip:remote_folder\n   从本地复制到远程，复制目录和下面的文件；\n * scp root@192.168.10.123:/home/work/others/music /home/work/music/1.mp3\n   从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可；\n\n\nrm 命令#\n\nrm 命令是用于删除目录和权限：\n\n * rm /home/work/music/1.mp3 删除指定文件；\n * rm -r /home/work/others/music 删除指定目录和目录下文件，包括子文件夹；\n * rm -rf /home/work/others/music 强制删除指定目录和目录下文件，包括子文件夹；\n\n\nmv 命令#\n\nmv 命令是用于移动文件到另外一个目录，或者可以当前目录使用另外一个名字：\n\n * mv /home/work/music/1.mp3 /home/work/music/2.mp3 移动指定文件，并重命名；\n * mv -r /home/work/others/music /home/work/ 移动指定目录和目录下文件到指定目录，包括子文件夹；\n\n\nwhich 命令#\n\nwhich 命令是用于查询应用安装路径：\n\n * which nginx 查询nginx安装路径；\n   \n   \n\n\nfind 命令#\n\n\npwd 命令#\n\npwd 命令是用于查询当前路径：\n\n * pwd 查询当前路径；\n   \n   \n\n\ncat 命令#\n\ncat 命令是用于显示文件内容：\n\n * cat nginx.conf 显示文件内容；\n   \n   \n   \n   * cat nginx.conf 显示文件内容；\n     \n     \n\n\ntail 命令#\n\ngrep 命令是用于查找文件里符合条件的字符串的命令：\n\n\ngrep 命令#\n\ngrep 命令是grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。\n\n * grep\n   [-abcEFGhHilLnqrsvVwxy][-A<显示列数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<\n   范本文件>][--help][范本样式][文件或目录...] grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。\n\n\nps 命令#\n\nps 命令是用于查看所有进程的命令：\n\n * ps -ef | grep 6379 查询进程中有6379内容的，一般查询端口；\n\n\ntar 命令#\n\ntar 命令是用于制作归档文件，释放归档文件：\n\n * -c: 建立压缩档案\n\n * -x：解压\n\n * -t：查看内容\n\n * -r：向压缩归档文件末尾追加文件\n\n * -u：更新原压缩包中的文件\n\n * -z：有gzip属性的\n\n * -j：有bz2属性的\n\n * -Z：有compress属性的\n\n * -v：显示所有过程\n\n * -O：将文件解开到标准输出\n\n * -f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名\n\n\n\n\n\n总结\n\n 1. *.tar 用 tar –xvf 解压\n 2. *.gz 用 gzip -d或者gunzip 解压\n 3. .tar.gz和.tgz 用 tar –xzf 解压\n 4. *.bz2 用 bzip2 -d或者用bunzip2 解压\n 5. *.tar.bz2用tar –xjf 解压\n 6. *.Z 用 uncompress 解压\n 7. *.tar.Z 用tar –xZf 解压\n 8. *.rar 用 unrar e解压\n 9. *.zip 用 unzip 解压\n\n\nvi 命令#\n\nvi 命令是用于文本编辑器：\n\n\nyum 命令#\n\nyum 命令 linux下的安装软件的命令\n\n\n\n\nuseradd 命令#\n\nuseradd 命令 添加用户账号 命令useradd [选项】 用户名-u\n：指定uid标记号-d：指定宿主目录，缺省默认为/home/用户名-e:指定账号失效时间-M：不为用户建立初始化宿主目录 （-d 与 -M\n不能同时使用）-s：指定用户登录的shell-g:指定用户的基本名-G：指定用户的附加组名-c：添加备注，显示在/etc/passwd第五字段\n\n\n\n\nuserdel 命令#\n\nuserdel 命令 删除用户账号命令userdel 用户名-r ： 删除用户的同时删除用户的宿主目录eg\n\n\n\n\nusermod 命令#\n\nusermod 命令 修改用户属性 命令usermod [选项] ... 用户名-l : 更改用户账号的登录名字-c : 修改用户的备注-L :\n锁定用户账号-U: 解锁用户账号eg：\n\n\n\n\ngroupadd 命令#\n\ngroupadd 命令 添加组账号命令注GID：组标识号格式\n\n\n\n\ngroupdel 命令#\n\ngroupdel 命令 删除组账号\n\n\n\n\npasswd 命令#\n\npasswd 命令 设置/更改用户口令passwd 【选项】 用户名-d : 清空用户密码-l ： 锁定用户账号-S：\n查看用户账号的状态（是否被锁定）-u：解锁用户账号-x，\n--maximum=DAYS:密码的最长有效时限-n，--miximum=DAYS:密码的最短有效时限-w，--warning=DAYS:在密码过期前多少天开始\n提醒用户-i, --inactive=DAYS:当密码过期后经过多少天该账号会被禁用\n\n\ngpasswd 命令#\n\ngpasswd 命令 设置组账号密码（极少用），添加，删除组成员 gpasswd [选项] ... 组账号名\n\n\ntree 命令#\n\ntree 命令 将所有文件以树的形式列出来\n\n * tree -l 2 查询层级\n\n\nlsof 命令#\n\nlsof 命令是英文list open file的简称，作用是列出系统上进程打开的所有文件，我们可以通过lsof命令查看这些文件信息：\n\n * lsof -i :6379 查看占用6379号端口的那个进程的信息；\n   \n   ","routePath":"/2024/02/29/linux-command/","lang":"","toc":[{"text":"ls 命令","id":"ls-命令","depth":2,"charIndex":102},{"text":"mkdir 命令","id":"mkdir-命令","depth":2,"charIndex":249},{"text":"cp 命令","id":"cp-命令","depth":2,"charIndex":322},{"text":"scp 命令","id":"scp-命令","depth":2,"charIndex":504},{"text":"rm 命令","id":"rm-命令","depth":2,"charIndex":927},{"text":"mv 命令","id":"mv-命令","depth":2,"charIndex":1103},{"text":"which 命令","id":"which-命令","depth":2,"charIndex":1288},{"text":"find 命令","id":"find-命令","depth":2,"charIndex":1359},{"text":"pwd 命令","id":"pwd-命令","depth":2,"charIndex":1370},{"text":"cat 命令","id":"cat-命令","depth":2,"charIndex":1422},{"text":"tail 命令","id":"tail-命令","depth":2,"charIndex":1529},{"text":"grep 命令","id":"grep-命令","depth":2,"charIndex":1569},{"text":"ps 命令","id":"ps-命令","depth":2,"charIndex":1823},{"text":"tar 命令","id":"tar-命令","depth":2,"charIndex":1897},{"text":"vi 命令","id":"vi-命令","depth":2,"charIndex":2376},{"text":"yum 命令","id":"yum-命令","depth":2,"charIndex":2401},{"text":"useradd 命令","id":"useradd-命令","depth":2,"charIndex":2436},{"text":"userdel 命令","id":"userdel-命令","depth":2,"charIndex":2634},{"text":"usermod 命令","id":"usermod-命令","depth":2,"charIndex":2705},{"text":"groupadd 命令","id":"groupadd-命令","depth":2,"charIndex":2815},{"text":"groupdel 命令","id":"groupdel-命令","depth":2,"charIndex":2864},{"text":"passwd 命令","id":"passwd-命令","depth":2,"charIndex":2900},{"text":"gpasswd 命令","id":"gpasswd-命令","depth":2,"charIndex":3127},{"text":"tree 命令","id":"tree-命令","depth":2,"charIndex":3197},{"text":"lsof 命令","id":"lsof-命令","depth":2,"charIndex":3250}],"domain":"","frontmatter":{"layout":"post","title":"Linux常用命令","date":"2024-02-29T10:00:00.000Z","categories":["Linux"],"tags":["linux","shell","command"]},"version":""},{"id":10,"title":"nginx配置","content":"nginx.conf基本配置有哪些？#\n\nnginx配置文件主要分成四个部分：\n\n * main，全局设置，影响其它部分所有设置\n * server，主机服务相关设置，主要用于指定虚拟主机域名、IP和端口\n * location，URL匹配特定位置后的设置，反向代理、内容篡改相关设置\n * upstream，上游服务器设置，负载均衡相关配置\n\n他们之间的关系式：server继承main，location继承server；\n\nupstream既不会继承指令也不会被继承。\n\n通用的配置和详解：\n\n\n\nlocation如何匹配？\n\n以 = 开头表示精确匹配 ^~ 开头表示uri以某个常规字符串开头，不是正则匹配 ~ 开头表示区分大小写的正则匹配 ~* 开头表示不区分大小写的正则匹配 /\n通用匹配, 如果没有其它匹配,任何请求都会匹配到 优先级： (location =) > (location 完整路径) > (location ^~ 路径)\n> (location ~,~* 正则顺序) > (location 部分起始路径) > (/)\n\n\n\n如何配置反向代理？\n\n\n\n来个实例看看：\n\n\n\n如何配置rewrite？\n\nrewrite功能就是集合正则表达式和标志位实现url重写和重定向。\n\nrewrite只能放在server{}、location{}、if(){}块中，并且只能对域名后边的出去传递参数外的字符串起作用。如URL：\n\nhttp://microloan-sms-platform.yxapp.xyz/proxy/sms/task/querydeleted?page=1&pages\nize=10\n\n只对/proxy/sms/task/querydeleted进行重写。\n\n如果相对域名或参数字符串起作用，可以使用全局变量匹配，也可以使用proxy_pass反向代理。\n\n表明看rewrite和location功能有点像，都能实现跳转，主要区别在于rewrite是在同一域名内更改获取资源的路径，而location是对一类路径做控制\n访问或反向代理，可以proxy_pass到其他机器。很多情况下rewrite也会写在location里，它们的执行顺序是：\n\n执行server块的rewrite指令执行location匹配执行选定的location中的rewrite指令\n\n如果其中某步URI被重写，则重新循环执行1-3，直到找到真实存在的文件；循环超过10次，则返回500 Internal Server Error错误。\n\nrewrite规则后边，通常会带有flag标志位：\n\nlast : 相当于Apache的[L]标记，表示完成rewritebreak : 停止执行当前虚拟主机的后续rewrite指令集redirect :\n返回302临时重定向，地址栏会显示跳转后的地址permanent : 返回301永久重定向，地址栏会显示跳转后的地址\n\nlast 和 break 区别：\n\nlast一般写在server和if中，而break一般使用在location中last不终止重写后的url匹配，即新的url会再从server走一遍匹配流程，而\nbreak终止重写后的匹配break和last都能组织继续执行后面的rewrite指令\n\nrewrite常用正则：\n\n. ： 匹配除换行符以外的任意字符? ： 重复0次或1次 ： 重复1次或更多次* ： 重复0次或更多次\\d ：匹配数字^ ： 匹配字符串的开始$ ：\n匹配字符串的介绍{n} ： 重复n次{n,} ： 重复n次或更多次 ： 匹配单个字符c[a-z] ： 匹配a-z小写字母的任意一个\n\n可以使用()来进行分组，可以通过$1的形式来引用。\n\n\n\n如何配置负载均衡？\n\nupstream是Nginx的HTTP Upstream模块，这个模块通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。\n\nNginx的负载均衡模块目前支持4种调度算法：\n\n轮询（默认）。每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。Weight\n指定轮询权值，Weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。ip_hash。每个请求按访问IP的hash结果分配，这样来自同\n一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。fair。这是比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和\n加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须\n下载Nginx的upstream_fair模块。url_hash。此方法按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高\n后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx 的hash软件包。\n\nupstream可以设定每个后端服务器在负载均衡调度中的状态，支持的状态参数:\n\ndown，表示当前的server暂时不参与负载均衡backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因\n此这台机器的压力最轻。max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream\n模块定义的错误。fail_timeout，在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。\n\n注，当负载调度算法为ip_hash时，后端服务器在负载均衡调度中的状态不能是weight和backup。\n\n\n\n如何设置页面缓存？\n\n页面缓存设置指令：\n\nproxy_cache_path : 指定缓存的路径和一些其他参数，缓存的数据存储在文件中，并且使用代理url的哈希值作为关键字与文件名。\n\nproxy_cache_path /data/nginx/cache/webserver levels=1:2 keys_zone=webserver:20m\nmax_size=1g;\n\nlevels参数指定缓存的子目录数。keys_zone指定活动的key和元数据存储在共享池（webserver为共享池名称，20m位共享池大小），inactiv\ne参数指定的时间内缓存的数据没有被请求则被删除，默认inactive为10分钟·max_size指定缓存空间的大小。\n\nproxy_cache : 设置一个缓存区域的名称，一个相同的区域可以在不同的地方使用。proxy_cache_valid :\n为不同的应答设置不同的缓存时间。如何设置读写分离？\n\nproxy_cache_valid : 为不同的应答设置不同的缓存时间。如何设置读写分离？\n\n","routePath":"/2024/02/27/nginx-configuration/","lang":"","toc":[{"text":"nginx.conf基本配置有哪些？","id":"nginxconf基本配置有哪些","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"layout":"post","title":"nginx配置","date":"2024-02-27T09:40:00.000Z","categories":["Web服务器"],"tags":["nginx"]},"version":""},{"id":11,"title":"配置nodejs环境","content":"建议使用最简单的软连接方式，只需要以下几个步骤就完成了配置，包括npm的配置\n\n 1. 下载node编译好的安装包\n    \n    \n\n 2. 获取root临时权限\n    \n    \n\n 3. 拷贝安装包到local目录下\n    \n    \n\n 4. 解压缩包\n    \n    \n\n 5. 设置命令软连接\n    \n    \n\n 6. 读取node版本\n    \n    \n\n 7. 配置profile文件（可选）\n    \n    ","routePath":"/2024/02/27/nodejs-configuration/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"post","title":"配置nodejs环境","date":"2024-02-27T09:33:00.000Z","categories":["语言"],"tags":["nodejs"]},"version":""},{"id":12,"title":"nginx配置二级目录子站点","content":"nginx配置二级目录子站点#\n\n站点部署时，我们经常会需要二级目录的子站点，今天说说如何配置\n\n * 主站点：http://www.zhifou.co\n * 子站点guide：http://www.zhifou.co/guide\n * 子站点ext：http://www.zhifou.co/ext\n\n配置和详解：\n\n\n\n相关资料\n\n * nginx.conf基本配置有哪些？\n * mac下安装Nginx及常用命令使用","routePath":"/2024/02/26/nginx-site/","lang":"","toc":[{"text":"nginx配置二级目录子站点","id":"nginx配置二级目录子站点","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"layout":"post","title":"nginx配置二级目录子站点","date":"2024-02-26T13:42:00.000Z","categories":["Web服务器"],"tags":["nginx"]},"version":""},{"id":13,"title":"Typescript在React中的类型应用","content":"一、组件声明#\n\n在React中，组件的声明方式有两种：函数组件和类组件， 来看看这两种类型的组件声明时是如何定义TS类型的。\n\n\n1. 类组件#\n\n类组件的定义形式有两种：React.Component 和\nReact.PureComponent，它们都是泛型接口，接收两个参数，第一个是props类型的定义，第二个是state类型的定义，这两个参数都不是必须的，没有\n时可以省略：\n\n\n\nReact.PureComponent 也是差不多的：\n\n\n\nReact.PureComponent是有第三个参数的，它表示getSnapshotBeforeUpdate的返回值。\n\n那PureComponent和Component 的区别是什么呢？它们的主要区别是PureComponent中的shouldComponentUpdate\n是由自身进行处理的，不需要我们自己处理，所以PureComponent可以在一定程度上提升性能。\n\n有时候可能会见到这种写法，实际上和上面的效果是一样的：\n\n\n\n那如果定义时候我们不知道组件的props的类型，只有在调用时才知道组件类型，该怎么办呢？这时泛型就发挥作用了：\n\n\n\n\n2. 函数组件#\n\n通常情况下，函数组件我是这样写的：\n\n\n\n除此之外，函数类型还可以使用React.FunctionComponent来定义，也可以使用其简写React.FC，两者效果是一样的。它是一个泛型接口，可以接收\n一个参数，参数表示props的类型，这个参数不是必须的。它们就相当于这样：\n\n\n\n最终的定义形式如下：\n\n\n\n当使用这种形式来定义函数组件时，props中默认会带有children属性，它表示该组件在调用时，其内部的元素，来看一个例子，首先定义一个组件，组件中引入了Ch\nild1和Child2组件：\n\n\n\nChild1组件结构如下：\n\n\n\n我们在Child1组件中打印了children属性，它的值是一个数组，包含Child2对象和后面的文本：\n\n\n\n使用 React.FC 声明函数组件和普通声明的区别如下：\n\n * React.FC 显式地定义了返回类型，其他方式是隐式推导的；\n * React.FC 对静态属性：displayName、propTypes、defaultProps 提供了类型检查和自动补全；\n * React.FC 为 children 提供了隐式的类型（ReactElement | null）。\n\n那如果我们在定义组件时不知道props的类型，只有调用时才知道，那就还是用泛型来定义props的类型。对于使用function定义的函数组件：\n\n\n\n如果使用箭头函数定义的函数组件，直接这样调用是错误的：\n\n\n\n必须使用extends关键字来定义泛型参数才能被成功解析：\n\n\n\n\n二、React内置类型#\n\n\n1. JSX.Element#\n\n先来看看JSX.Element类型的声明：\n\n\n\n可以看到，JSX.Element是ReactElement的子类型，它没有增加属性，两者是等价的。也就是说两种类型的变量可以相互赋值。\n\nJSX.Element 可以通过执行 React.createElement 或是转译 JSX 获得：\n\n\n\n\n2. React.ReactElement#\n\nReact 的类型声明文件中提供了 React.ReactElement＜T＞，它可以让我们通过传入＜T＞来注解类组件的实例化，它在声明文件中的定义如下：\n\n\n\nReactElement是一个接口，包含type,props,key三个属性值。该类型的变量值只能是两种：null 和 ReactElement实例。\n\n通常情况下，函数组件返回ReactElement（JXS.Element）的值。\n\n\n3. React.ReactNode#\n\nReactNode类型的声明如下：\n\n\n\n可以看到，ReactNode是一个联合类型，它可以是string、number、ReactElement、null、boolean、ReactNodeArray\n。由此可知。ReactElement类型的变量可以直接赋值给ReactNode类型的变量，但反过来是不行的。\n\n类组件的 render 成员函数会返回 ReactNode 类型的值：\n\n\n\n上面的代码中，给component变量设置了类型是Mycomponent类型的react实例，这时只能给其赋值其为MyComponent的实例组件。\n\n通常情况下，类组件通过 render() 返回 ReactNode的值。\n\n\n4. CSSProperties#\n\n先来看看React的声明文件中对CSSProperties 的定义：\n\n\n\nReact.CSSProperties是React基于TypeScript定义的CSS属性类型，可以将一个方法的返回值设置为该类型：\n\n\n\n这里divStyle组件的返回值就是React.CSSProperties类型。\n\n我们还可以定义一个CSSProperties类型的变量：\n\n\n\n这个变量可以在HTML标签的style属性上使用：\n\n\n\n在React的类型声明文件中，style属性的类型如下：\n\n\n\n\n三、React Hooks#\n\n\n1. useState#\n\n默认情况下，React会为根据设置的state的初始值来自动推导state以及更新函数的类型：\n\n\n\n如果已知state 的类型，可以通过以下形式来自定义state的类型：\n\n\n\n如果初始值为null，需要显式地声明 state 的类型：\n\n\n\n如果state是一个对象，想要初始化一个空对象，可以使用断言来处理：\n\n\n\n实际上，这里将空对象{}断言为IUser接口就是欺骗了TypeScript的编译器，由于后面的代码可能会依赖这个对象，所以应该在使用前及时初始化 user\n的值，否则就会报错。\n\n下面是声明文件中 useState 的定义：\n\n\n\n可以看到，这里定义两种形式，分别是有初始值和没有初始值的形式。\n\n\n2. useEffect#\n\nuseEffect的主要作用就是处理副作用，它的第一个参数是一个函数，表示要清除副作用的操作，第二个参数是一组值，当这组值改变时，第一个参数的函数才会执行，这让\n我们可以控制何时运行函数来处理副作用：\n\n\n\n当函数的返回值不是函数或者effect函数中未定义的内容时，如下：\n\n\n\nTypeScript就会报错：\n\n\n\n来看看useEffect在类型声明文件中的定义：\n\n\n\n可以看到，useEffect的第一个参数只允许返回一个函数。\n\n\n3. useRef#\n\n当使用 useRef 时，我们可以访问一个可变的引用对象。可以将初始值传递给 useRef，它用于初始化可变 ref\n对象公开的当前属性。当我们使用useRef时，需要给其指定类型：\n\n\n\n这里给实例的类型指定为了input输入框类型。\n\n当useRef的初始值为null时，有两种创建的形式，第一种：\n\n\n\n这种形式下，ref1.current是只读的（read-only），所以当我们将它的innerText属性重新赋值时会报以下错误：\n\n\n\n那该怎么将current属性变为动态可变的，先来看看类型声明文件中 useRef 是如何定义的：\n\n\n\n这段代码的第十行的告诉我们，如果需要useRef的直接可变，就需要在泛型参数中包含'| null'，所以这就是当初始值为null的第二种定义形式：\n\n\n\n这种形式下，nameInput.current就是可写的。不过两种类型在使用时都需要做类型检查：\n\n\n\n那么问题来了，为什么第一种写法在没有操作current时没有报错呢？因为useRef在类型定义时具有多个重载声明，第一种方式就是执行的以下函数重载：\n\n\n\n从上useRef的声明中可以看到，function\nuseRef的返回值类型化是MutableRefObject，这里面的T就是参数的类型T，所以最终nameInput\n的类型就是React.MutableRefObject。\n\n注意，上面用到了HTMLInputElement类型，这是一个标签类型，这个操作就是用来访问DOM元素的。\n\n\n4. useCallback#\n\n先来看看类型声明文件中对useCallback的定义：\n\n\n\nuseCallback接收一个回调函数和一个依赖数组，只有当依赖数组中的值发生变化时才会重新执行回调函数。来看一个例子：\n\n\n\n这里我们没有给回调函数中的参数a定义类型，所以下面的调用方式都不会报错：\n\n\n\n尽管add方法的两个参数都是number类型，但是上述调用都能够用执行。所以为了更加严谨，我们需要给回调函数定义具体的类型：\n\n\n\n这时候如果再给回调函数传入字符串就会报错了：\n\n所有，需要注意，在使用useCallback时需要给回调函数的参数指定类型。\n\n\n5. useMemo#\n\n先来看看类型声明文件中对useMemo的定义：\n\n\n\nuseMemo和useCallback是非常类似的，但是它返回的是一个值，而不是函数。所以在定义useMemo时需要定义返回值的类型：\n\n\n\n如果返回值不一致，就会报错：\n\n\n\n\n6. useContext#\n\nuseContext需要提供一个上下文对象，并返回所提供的上下文的值，当提供者更新上下文对象时，引用这些上下文对象的组件就会重新渲染：\n\n\n\n在使用useContext时，会自动推断出提供的上下文对象的类型，所以并不需要我们手动设置context的类型。当前，我们也可以使用泛型来设置context的类\n型：\n\n\n\n下面是useContext在类型声明文件中的定义：\n\n\n\n\n7. useReducer#\n\n有时我们需要处理一些复杂的状态，并且可能取决于之前的状态。这时候就可以使用useReducer，它接收一个函数，这个函数会根据之前的状态来计算一个新的state\n。其语法如下：\n\n\n\n来看下面的例子：\n\n\n\n当前的状态是无法推断出来的，可以给reducer函数添加类型，通过给reducer函数定义state和action来推断 useReducer\n的类型，下面来修改上面的例子：\n\n\n\n这样，在Counter函数中就可以推断出类型。当我们试图使用一个不存在的类型时，就会报错：\n\n\n\n除此之外，还可以使用泛型的形式来实现reducer函数的类型定义：\n\n\n\n其实dispatch方法也是有类型的：\n\n\n\n可以看到，dispatch的类型是：React.Dispatch，上面示例的完整代码如下：\n\n\n\n\n四、事件处理#\n\n\n1. Event 事件类型#\n\n在开发中我们会经常在事件处理函数中使用event事件对象，比如在input框输入时实时获取输入的值；使用鼠标事件时，通过 clientX、clientY\n获取当前指针的坐标等等。\n\n我们知道，Event是一个对象，并且有很多属性，这时很多人就会把 event\n类型定义为any，这样的话TypeScript就失去了它的意义，并不会对event事件进行静态检查，如果一个键盘事件触发了下面的方法，也不会报错：\n\n\n\n由于Event事件对象中有很多的属性，所以我们也不方便把所有属性及其类型定义在一个interface中，所以React在声明文件中给我们提供了Event事件对象\n的类型声明。\n\n常见的Event 事件对象如下：\n\n * 剪切板事件对象：ClipboardEvent\n * 拖拽事件对象：DragEvent\n * 焦点事件对象：FocusEvent\n * 表单事件对象：FormEvent\n * Change事件对象：ChangeEvent\n * 键盘事件对象：KeyboardEvent\n * 鼠标事件对象：MouseEvent\n * 触摸事件对象：TouchEvent\n * 滚轮事件对象：WheelEvent\n * 动画事件对象：AnimationEvent\n * 过渡事件对象：TransitionEvent\n\n可以看到，这些Event事件对象的泛型中都会接收一个Element元素的类型，这个类型就是我们绑定这个事件的标签元素的类型，标签元素类型将在下面的第五部分介绍。\n\n来看一个简单的例子：\n\n\n\n这里就给onChange方法的事件对象定义为了FormEvent类型，并且作用的对象是一个HTMLInputElement类型的标签（input标签）\n\n可以来看下MouseEvent事件对象和ChangeEvent事件对象的类型声明，其他事件对象的声明形似也类似：\n\n\n\n在很多事件对象的声明文件中都可以看到 EventTarget\n的身影。这是因为，DOM的事件操作（监听和触发），都定义在EventTarget接口上。EventTarget 的类型声明如下：\n\n\n\n比如在change事件中，会使用的e.target来获取当前的值，它的的类型就是EventTarget。来看下面的例子：\n\n\n\n这里定义了一个input输入框，当触发onChange事件时，会调用onSourceChange方法，该方法的参数e的类型就是：React.ChangeEven\nt，而e.target的类型就是EventTarget：\n\n\n\n再来看一个例子：\n\n\n\n这点代码中，点击某个盒子，就将它设置为当前的盒子，方便执行其他操作。当鼠标点击盒子时，会触发handleChangeCurren方法，该方法有两个参数，第二个参\n数是event对象，在方法中执行了e.stopPropagation();是为了阻止冒泡事件，这里的stopPropagation()实际上并不是鼠标事件Mou\nseEvent的属性，它是合成事件上的属性，来看看声明文件中的定义：\n\n\n\n可以看到，这里的stopPropagation()是一层层的继承来的，最终来自于BaseSyntheticEvent合成事件类型。原生的事件集合Syntheti\ncEvent就是继承自合成时间类型。SyntheticEvent泛型接口接收当前的元素类型和事件类型，如果不介意这两个参数的类型，完全可以这样写：\n\n\n\n\n2. 事件处理函数类型#\n\n说完事件对象类型，再来看看事件处理函数的类型。React也为我们提供了贴心的提供了事件处理函数的类型声明，来看看所有的事件处理函数的类型声明：\n\n\n\n这里面的T的类型也都是Element，指的是触发该事件的HTML标签元素的类型，下面第五部分会介绍。\n\nEventHandler会接收一个E，它表示事件处理函数中 Event 对象的类型。bivarianceHack 是事件处理函数的类型定义，函数接收一个\nEvent 对象，并且其类型为接收到的泛型变量 E 的类型, 返回值为 void。\n\n还看上面的那个例子：\n\n\n\n这里给onChange方法定义了方法的类型，它是一个ChangeEventHandler的类型，并且作用的对象是一个HTMLImnputElement类型的标签\n（input标签）。\n\n\n五、HTML标签类型#\n\n\n1. 常见标签类型#\n\n在项目的依赖文件中可以找到HTML标签相关的类型声明文件：\n\n\n\n所有的HTML标签的类型都被定义在 intrinsicElements 接口中，常见的标签及其类型如下：\n\n\n\n那什么时候会使用到标签类型呢，上面第四部分的Event事件类型和事件处理函数类型中都使用到了标签的类型。上面的很多的类型都需要传入一个ELement类型的泛型参\n数，这个泛型参数就是对应的标签类型值，可以根据标签来选择对应的标签类型。这些类型都继承自HTMLElement类型，如果使用时对类型类型要求不高，可以直接写HT\nMLELement。比如下面的例子：\n\n\n\n其实，在直接操作DOM时也会用到标签类型，虽然我们现在通常会使用框架来开发，但是有时候也避免不了直接操作DOM。比如我在工作中，项目中的某一部分组件是通过npm\n来引入的其他组的组件，而在很多时候，我有需要动态的去个性化这个组件的样式，最直接的办法就是通过原生JavaScript获取到DOM元素，来进行样式的修改，这时候\n就会用到标签类型。\n\n来看下面的例子：\n\n\n\n这是我最近写的一段代码（略微删改），在第一页有个add-ele元素的时候就删除它。这里我们将item.firstChild断言成了HTMLDivElement类\n型，如果不断言，item.firstChild的类型就是ChildNode，而ChildNode类型中是不存在classList属性的，所以就就会报错，当我们把\n他断言成HTMLDivElement类型时，就不会报错了。很多时候，标签类型可以和断言（as）一起使用。\n\n后面在removeChild时又使用了as断言，为什么呢？item.firstChild不是已经自动识别为ChildNode类型了吗？因为TS会认为，我们可能不\n能获取到类名为paper的元素，所以item.firstChild的类型就被推断为ChildNode |\nnull，我们有时候比TS更懂我们定义的元素，知道页面一定存在paper 元素，所以可以直接将item.firstChild断言成ChildNode类型。\n\n\n2. 标签属性类型#\n\n众所周知，每个HTML标签都有自己的属性，比如Input框就有value、width、placeholder、max-length等属性，下面是Input框的属\n性类型定义：\n\n\n\n如果我们需要直接操作DOM，就可能会用到元素属性类型，常见的元素属性类型如下：\n\n * HTML属性类型：HTMLAttributes\n * 按钮属性类型：ButtonHTMLAttributes\n * 表单属性类型：FormHTMLAttributes\n * 图片属性类型：ImgHTMLAttributes\n * 输入框属性类型：InputHTMLAttributes\n * 链接属性类型：LinkHTMLAttributes\n * meta属性类型：MetaHTMLAttributes\n * 选择框属性类型：SelectHTMLAttributes\n * 表格属性类型：TableHTMLAttributes\n * 输入区属性类型：TextareaHTMLAttributes\n * 视频属性类型：VideoHTMLAttributes\n * SVG属性类型：SVGAttributes\n * WebView属性类型：WebViewHTMLAttributes\n\n一般情况下，我们是很少需要在项目中显式的去定义标签属性的类型。如果子级去封装组件库的话，这些属性就能发挥它们的作用了。来看例子（来源于网络，仅供学习）：\n\n\n\n这段代码就是用来封装一个buttom按钮，在button的基础上添加了一些自定义属性，比如上面将button的类型使用交叉类型（&）获得自定义属性和原生\nbutton 属性 ：\n\n\n\n可以看到，标签属性类型在封装组件库时还是很有用的，更多用途可以自己探索~\n\n\n六、工具泛型#\n\n在项目中使用一些工具泛型可以提高我们的开发效率，少写很多类型定义。下面来看看有哪些常见的工具泛型，以及其使用方式。\n\n\n1. Partial#\n\nPartial 作用是将传入的属性变为可选项。适用于对类型结构不明确的情况。它使用了两个关键字：keyof和in，先来看看他们都是什么含义。keyof\n可以用来取得接口的所有 key 值：\n\n\n\nin关键字可以遍历枚举类型,：\n\n\n\nkeyof 可以产生联合类型, in 可以遍历枚举类型, 所以经常一起使用, 下面是Partial工具泛型的定义：\n\n\n\n这里，keyof T 获取 T 所有属性名, 然后使用 in 进行遍历, 将值赋给 P, 最后 T[P] 取得相应属性的值。中间的?就用来将属性设置为可选。\n\n使用示例如下：\n\n\n\n\n2. Required#\n\nRequired 的作用是将传入的属性变为必选项，和上面的工具泛型恰好相反，其声明如下：\n\n\n\n可以看到，这里使用-?将属性设置为必选，可以理解为减去问号。使用形式和上面的Partial差不多：\n\n\n\n\n3. Readonly#\n\n将T类型的所有属性设置为只读（readonly），构造出来类型的属性不能被再次赋值。Readonly的声明形式如下：\n\n\n\n使用示例如下：\n\n\n\n可以看到，通过 Readonly将IPerson的属性转化成了只读，不能再进行赋值操作。\n\n\n4. Pick#\n\n从T类型中挑选部分属性K来构造新的类型。它的声明形式如下：\n\n\n\n使用示例如下：\n\n\n\n\n5. Record#\n\nRecord 用来构造一个类型，其属性名的类型为K，属性值的类型为T。这个工具泛型可用来将某个类型的属性映射到另一个类型上，下面是其声明形式：\n\n\n\n使用示例如下：\n\n\n\n\n6. Exclude#\n\nExclude 就是从一个联合类型中排除掉属于另一个联合类型的子集，下面是其声明的形式：\n\n\n\n使用示例如下：\n\n\n\n\n7. Omit#\n\n上面的Pick 和 Exclude 都是最基础基础的工具泛型，很多时候用 Pick 或者 Exclude 还不如直接写类型更直接。而 Omit\n就基于这两个来做的一个更抽象的封装，它允许从一个对象中剔除若干个属性，剩下的就是需要的新类型。下面是它的声明形式：\n\n\n\n使用示例如下：\n\n\n\n\n8. ReturnType#\n\nReturnType会返回函数返回值的类型，其声明形式如下：\n\n\n\n使用示例如下：\n\n\n\n这里使用 typeof 是为了获取 foo 的函数签名，等价于 (type: any) => boolean。\n\n\n七、其他#\n\n\n1. import React#\n\n在React项目中使用TypeScript时，普通组件文件后缀为.tsx，公共方法文件后缀为.ts。在. tsx 文件中导入 React 的方式如下：\n\n\n\n这是一种面向未来的导入方式，如果想在项目中使用以下导入方式：\n\n\n\n就需要在tsconfig.json配置文件中进行如下配置：\n\n\n\n\n2. Types or Interfaces？#\n\n我们可以使用types或者Interfaces来定义类型吗，那么该如何选择他俩呢？建议如下：\n\n * 在定义公共 API 时(比如编辑一个库）使用 interface，这样可以方便使用者继承接口，这样允许使用者通过声明合并来扩展它们；\n * 在定义组件属性（Props）和状态（State）时，建议使用 type，因为 type 的约束性更强。\n\ninterface 和 type 在 ts 中是两个不同的概念，但在 React 大部分使用的 case 中，interface 和 type\n可以达到相同的功能效果，type 和 interface 最大的区别是：type 类型不能二次编辑，而 interface 可以随时扩展：\n\n\n\ntype对于联合类型是很有用的，比如：type Type = TypeA | TypeB。而interface更适合声明字典类行，然后定义或者扩展它。\n\n\n3. 懒加载类型#\n\n如果我们想在React router中使用懒加载，React也为我们提供了懒加载方法的类型，来看下面的例子：\n\n\n\n下面是懒加载类型和lazy方法在声明文件中的定义：\n\n\n\n\n4. 类型断言#\n\n类型断言（Type\nAssertion）可以用来手动指定一个值的类型。在React项目中，断言还是很有用的，。有时候推断出来的类型并不是真正的类型，很多时候我们可能会比TS更懂我们\n的代码，所以可以使用断言（使用as关键字）来定义一个值得类型。\n\n来看下面的例子：\n\n\n\n当TypeScript不确定一个联合类型的变量到底是哪个类型时，就只能访问此联合类型的所有类型里共有的属性或方法，所以现在加了对参数target和返回值的类型定\n义之后就会报错。这时就可以使用断言，将target的类型断言成string类型：\n\n\n\n需要注意，类型断言并不是类型转换，断言成一个联合类型中不存在的类型是不允许的。\n\n再来看一个例子，在调用一个方法时传入参数：这里就提示我们这个参数可能是u\nndefined，而通过业务知道这个值是一定存在的，所以就可以将它断言成数字：data?.subjectId as number\n\n除此之外，上面所说的标签类型、组件类型、时间类型都可以使用断言来指定给一些数据，还是要根据实际的业务场景来使用。\n\n感悟：使用类型断言真的能解决项目中的很多报错~\n\n\n5. 枚举类型#\n\n枚举类型在项目中的作用也是不可忽视的，使用枚举类型可以让代码的扩展性更好，当我想更改某属性值时，无需去全局更改这个属性，只要更改枚举中的值即可。通常情况下，最好\n新建一个文件专门来定义枚举值，便于引用。\n\n关于在React项目中如何优雅的使用TypeScript就先介绍这么多，后面有新的内容会再分享给大家。如果觉得不错就点个赞吧！","routePath":"/2024/02/25/typescript-react-type/","lang":"","toc":[{"text":"一、组件声明","id":"一组件声明","depth":2,"charIndex":-1},{"text":"1. 类组件","id":"1-类组件","depth":3,"charIndex":65},{"text":"2. 函数组件","id":"2-函数组件","depth":3,"charIndex":506},{"text":"二、React内置类型","id":"二react内置类型","depth":2,"charIndex":1173},{"text":"1. JSX.Element","id":"1-jsxelement","depth":3,"charIndex":1188},{"text":"2. React.ReactElement","id":"2-reactreactelement","depth":3,"charIndex":1355},{"text":"3. React.ReactNode","id":"3-reactreactnode","depth":3,"charIndex":1580},{"text":"4. CSSProperties","id":"4-cssproperties","depth":3,"charIndex":1913},{"text":"三、React Hooks","id":"三react-hooks","depth":2,"charIndex":2176},{"text":"1. useState","id":"1-usestate","depth":3,"charIndex":2193},{"text":"2. useEffect","id":"2-useeffect","depth":3,"charIndex":2518},{"text":"3. useRef","id":"3-useref","depth":3,"charIndex":2754},{"text":"4. useCallback","id":"4-usecallback","depth":3,"charIndex":3420},{"text":"5. useMemo","id":"5-usememo","depth":3,"charIndex":3703},{"text":"6. useContext","id":"6-usecontext","depth":3,"charIndex":3833},{"text":"7. useReducer","id":"7-usereducer","depth":3,"charIndex":4037},{"text":"四、事件处理","id":"四事件处理","depth":2,"charIndex":4407},{"text":"1. Event 事件类型","id":"1-event-事件类型","depth":3,"charIndex":4417},{"text":"2. 事件处理函数类型","id":"2-事件处理函数类型","depth":3,"charIndex":5879},{"text":"五、HTML标签类型","id":"五html标签类型","depth":2,"charIndex":6248},{"text":"1. 常见标签类型","id":"1-常见标签类型","depth":3,"charIndex":6262},{"text":"2. 标签属性类型","id":"2-标签属性类型","depth":3,"charIndex":7162},{"text":"六、工具泛型","id":"六工具泛型","depth":2,"charIndex":7912},{"text":"1. Partial","id":"1-partial","depth":3,"charIndex":7981},{"text":"2. Required","id":"2-required","depth":3,"charIndex":8264},{"text":"3. Readonly","id":"3-readonly","depth":3,"charIndex":8380},{"text":"4. Pick<T, K extends keyof T>","id":"4-pickt-k-extends-keyof-t","depth":3,"charIndex":-1},{"text":"5. Record<K extends keyof any, T>","id":"5-recordk-extends-keyof-any-t","depth":3,"charIndex":-1},{"text":"6. Exclude<T, U>","id":"6-excludet-u","depth":3,"charIndex":-1},{"text":"7. Omit<T, K extends keyof any>","id":"7-omitt-k-extends-keyof-any","depth":3,"charIndex":-1},{"text":"8. ReturnType","id":"8-returntype","depth":3,"charIndex":8896},{"text":"七、其他","id":"七其他","depth":2,"charIndex":9015},{"text":"1. import React","id":"1-import-react","depth":3,"charIndex":9023},{"text":"2. Types or Interfaces？","id":"2-types-or-interfaces","depth":3,"charIndex":9188},{"text":"3. 懒加载类型","id":"3-懒加载类型","depth":3,"charIndex":9611},{"text":"4. 类型断言","id":"4-类型断言","depth":3,"charIndex":9710},{"text":"5. 枚举类型","id":"5-枚举类型","depth":3,"charIndex":10209}],"domain":"","frontmatter":{"layout":"post","title":"Typescript在React中的类型应用","date":"2024-02-25T16:40:00.000Z","categories":["语言"],"tags":["typescript","react"]},"version":""},{"id":14,"title":"ffmpeg 是一个命令行音视频后期处理软件","content":"ffmpeg 是一个命令行音视频后期处理软件#\n\n参数列表#\n\n * -i input_file：指定输入文件的路径和名称。示例：-i input.mp4\n * -ss position：指定从输入文件的哪个时间位置开始处理，格式为 HH:MM:SS.xxx（小时:分钟:秒.毫秒）。示例：-ss\n   00:01:30.500 表示从 1 分 30.5 秒开始处理。\n * -t duration：指定处理的持续时间，格式为 HH:MM:SS.xxx（小时:分钟:秒.毫秒）。示例：-t 00:00:45 表示处理 45\n   秒的内容。\n * -vf filtergraph：指定视频过滤器图形，用于对视频进行各种处理，如调整大小、裁剪、旋转、滤镜等。示例：-vf \"scale=640:480\"\n   表示将视频调整为 640x480 的大小。\n * -af filtergraph：指定音频过滤器图形，用于对音频进行各种处理，如音频增益、降噪、混音等。示例：-af \"volume=2.0\"\n   表示将音频增益调整为原来的 2 倍。\n * -c:v codec：指定视频编解码器。示例：-c:v libx264 表示使用 libx264 编码器进行视频编码。\n * -c:a codec：指定音频编解码器。示例：-c:a aac 表示使用 AAC 编码器进行音频编码。\n * -b:v bitrate：指定视频的比特率，即视频的质量。较高的比特率通常意味着更好的视频质量，但文件大小也会增加。示例：-b:v 1000k\n   表示视频比特率为 1000kbps。\n * -b:a bitrate：指定音频的比特率，即音频的质量。较高的比特率通常意味着更好的音频质量，但文件大小也会增加。示例：-b:a 128k\n   表示音频比特率为 128kbps。\n * -r framerate：指定视频的帧率，即每秒播放的画面数量。较高的帧率可以获得更流畅的视频，但也会增加文件大小。示例：-r 30 表示视频帧率为 30\n   帧每秒。\n * -y 不询问直接覆盖原有的同名文件\n\n\n1. 裁剪命令#\n\n参数说明#\n\n * -i input_file：指定输入文件的路径和名称。示例：-i input.mp3\n\n * -ss position：指定从输入文件的哪个时间位置开始处理，格式为 HH:MM:SS.xxx（小时:分钟:秒.毫秒）。示例：-ss\n   00:01:30.500 表示从 1 分 30.5 秒开始处理。\n\n * -t duration：指定处理的持续时间，格式为 HH:MM:SS.xxx（小时:分钟:秒.毫秒）。示例：-t 00:00:45 表示处理 45\n   秒的内容。\n\n * -to 终止点时间\n\n * -c copy 表示不改变音频和视频的编码格式，直接拷贝，提升效率\n\n * output.mp3 为处理结果文件\n   \n   \n\n\n2. 合成命令#\n\n\n2.1 混合合成#\n\n参数说明#\n\n * -i 文件 1.mp3 和 2.mp3 为待合成的两个源文件\n\n * -filter_complex 过滤器参数\n\n * amix=inputs 配置输入的整体样本数\n\n * duration，first：长度取决于第一个文件，longest：长度取决于时间最长文件，shortest：长度取决于时间最短文件\n\n * dropout_transition：输入流结束时用于体积重新规范化的过渡时间\n\n * -f mp3 设置导出文件格式\n   \n   \n\n\n2.2 连接合成#\n\n参数说明#\n\n * concat 合并文件指令\n   \n   \n\n * 使用txt文件集合concat合并，视频合并使用这个list合并方式\n   \n   \n\n\n2.3 淡出效果#\n\n参数说明#\n\n * afade 淡入淡出指令\n\n * 从 st 秒开始，经过 d 秒钟的淡出效果\n   \n   \n\n\n2.4 合并音频#\n\n参数说明#\n\n\n\n\n2.5 合并视频#\n\n首先需要将原视频的声音删除。这里的文件名需要加上英文引号，如果不加的话，会提示No such file or directory。\n\n\n\n然后将无声视频和音频融合\n\n\n\n即可获得消去人声的视频。但笔者口语不好，觉得原视频的语速有些快了，故又调整了视频倍速为0.8倍速。\n\n\n\n这条指令同时调整视频倍速和音频倍速，setpts=(倍速的倒数)*PTS[v]，atempo=(倍速)[a]\n\n\n2.6 添加水印#\n\n\n\n\n2.7 抠像合并#\n\n * -vf filtergraph：指定视频过滤器图形，用于对视频进行各种处理，如调整大小、裁剪、旋转、滤镜等。示例：-vf \"scale=640:480\"\n   表示将视频调整为 640x480 的大小。\n\n\n\n\n3. 转换命令#\n\n\n3.1 格式转换#\n\n参数说明#\n\n * -i 文件，a.mp3 为待处理源文件\n\n * -ar 音频抽样率\n\n * -ac 音频Channel数\n\n * -f 强制输出格式 例如mp3, wav等\n   \n   \n\n\n3.2 图片格式转换#\n\n\n\n\n4. 调整命令#\n\n\n4.1 音量调整#\n\n参数说明#\n\n * -i 文件，input.mp3 为待处理源文件\n\n * -af filtergraph：指定音频过滤器图形，用于对音频进行各种处理，如音频增益、降噪、混音等。示例：-af \"volume=2.0\"\n   表示将音频增益调整为原来的 2 倍。\n   \n   \n   \n   dB的换算公式 1.1 dB = 1.1 倍，2 dB = 1.25倍，3 dB = 1.4倍，6 dB = 2 倍，10 dB = 3 倍，20 dB\n   = 10 倍，30 dB = 30 倍。其它就可以用上述数值换算，并不困难。(反过来 – 6 dB 就是 1/2 = 0.5)\n   2.在换算时要把握一个原则，dB数值的相加 等于 倍数的相乘。 例如：40 dB = 20dB + 20 dB = 10 * 10 = 100 倍\n   -20dB谱宽就是信号衰减到十分之一时的频谱带宽。\n\n\n4.2 升降调#\n\n\n\n\n4.3 音频速率调整#\n\n改变音频速率最简单的方法是直接调整音频的采样率，但是与此同时，这种方法会改变音频的音色。目前一般采用对原音进行重采样，差值等方法来实现。下面这行命令的倍率调整范\n围为0.5到2。\n\n\n\n如果想要再快的话，需要更改命令，通过将多个atempo过滤器串接在一起来绕过这个限制。\n\n\n\n将对输入文件 test_cut.mp3 应用音频效果，包括加速 2 倍(atempo)、高通滤波器(highpass)和低通滤波器(lowpass)，并保存为\ntest_cut_ahl.mp3\n\n\n\n\n4.4 视频速率调整#\n\n改变视频的播放速率是通过修改视频的表示时间戳（PTS）来实现的。举个简单的例子，如果在时间戳1和2处显示两个连续帧，我们想要加快视频速度，那么这两个时间戳需要分\n别变为0.5和1。因此，我们必须把他们乘以0.5。\n\n\n\n对视频进行加速时，为了不丢帧，可以利用-r 参数指定输出的fps。 一般来说，视频倍速还需要将视频中的音频也一同倍速，通过混合的过滤图实现，命令如下，\n\n\n\n\n4.5 添加封面#\n\n从 test.mp3 音频文件中提取音频流，并从 test.jpeg 图像文件中提取封面图像。然后，它将使用-map\n选项将音频流和封面图像流映射到输出文件。-c copy 选项用于直接复制音频流和封面图像流，而不进行重新编码。-id3v2_version 3 选项用于设置\nID3 标签版本为 3，以确保兼容性。-metadata:s:v 选项用于指定封面图像的元数据，如标题和注释。\n\n\n\n\n5. 提取命令#\n\n\n5.1 从视频中提取音频#\n\n参数说明#\n\n * -map 提取视频-音频流的序号\n * -b:a 码率 kb/s\n * -f 强制输出格式 例如mp3, wav等\n * -vn 表示去除视频流，v 代表视频，n 代表 no 也就是无视频的意思\n * acodec: 指定音频编码器，copy 指明只拷贝，不做编解码\n\n\n\n查看视频，包含的视频流、音频流如下： encoder : libebml v1.2.3 + libmatroska v1.3.0 Duration:\n01:42:13.09, start: 0.000000, bitrate: 2954 kb/s Stream #0:0: Video: h264\n(High), yuv420p, 1024x576 [SAR 1:1 DAR 16:9], 23.98 fps Stream #0:1(eng): Audio:\nac3, 48000 Hz, 384 kb/s (default) title : 英语 Stream #0:2(chi): Audio: ac3, 48000\nHz, 384 kb/s title : 台配 Stream #0:3(chi): Audio: ac3, 48000 Hz, 384 kb/s title :\n粤语\n\n查看原音视频文件音轨频率\n\n\n\n命令执行后找到音轨的Stream，频率为48000Hz；\n\n\n\n\n5.2 提取YUV#\n\n * -c:v rawvideo 指定将视频转成原始数据\n * -pixel_format yuv420p 指定转换格式为 yuv420p\n\n\n\n\n6. 消音命令#\n\n参数说明#\n\n * -i 文件，input.mp3 为待处理源文件\n\n * -ac 音频Channel数\n   \n   \n\n\n7. 录制命令#\n\n参数说明#\n\n * -f avfoundation 输入设备，从 Mac 的音频输入设备（通常是麦克风）录制音频\n\n * -i 指定从哪儿采集数据，它是一个文件索引号。在我的电脑上，1 代表桌面（可以通过上面的命令查询设备索引号）\n\n * -r 指定帧率。按 ffmpeg 官方文档说-r 与-framerate 作用相同，但实际测试时发现不同。-framerate 用于限制输入，而-r\n   用于限制输出。\n\n * -framerate 限制视频的采集帧率。这个必须要根据提示要求进行设置，如果不设置就会报错。\n\n * \":0\" 参数表示默认的音频输入设备\n\n * \"1:0\" 参数表示\"视频输入设备:音频输入设备\"\n   \n   \n\n\n8. 视频处理#\n\n\n8.1 视频转码#\n\n\n\n\n8.2 抽取视频流#\n\n * vcodec: 指定视频编码器，copy 指明只拷贝，不做编解码。\n * an: a 代表视频，n 代表 no 也就是无音频的意思。\n\n\n\n\n8.2 视频压缩#\n\n * -b:v 视频码率设置\n * -vf scale 指定使用简单过滤器 scale，iw/2:-1 中的 iw 指定按整型取视频的宽度。-1表示高度随宽度一起变化。\n\n\n\n\n8.2 视频速率调整#\n\n * -vf scale 指定使用简单过滤器 scale，iw/2:-1 中的 iw 指定按整型取视频的宽度。-1表示高度随宽度一起变化。\n\n\n\n\n8.3 视频裁剪#\n\n * crop 格式：crop=w:h:x :y\n   \n   * w: 输出的宽度。可以使用 in_w 表式输入视频的宽度。\n   * h: 输出的高度。可以使用 in_h 表式输入视频的高度。\n   * x : X 坐标\n   * y : Y 坐标\n   \n   如果 x 和 y 设置为 0,说明从左上角开始裁剪。如果不写是从中心点裁剪。\n\n * -strict -2 指明音频使有 AAC\n\n * -f hls 转成 m3u8 格式\n\n * -vf 视频过滤\n\n\n\n\n8.4 视频翻转#\n\n * hflip 水平翻转\n * 如果要修改为垂直翻转可以用 vflip\n\n\n\n\n8.5 视频截图#\n\n * 从上面的 out.mp4 中提取第 10 秒的视频帧，并将其保存为输出文件 output.jpg。参数-vframes 1表示只提取一帧。\n\n\n\n\n8.6 去除水印#\n\n\n\n\n8.7 添加水印#\n\n * -vf 中的 movie 指定 logo 位置。scale 指定 logo 大小。overlay 指定 logo 摆放的位置\n\n\n\n\n8.8 添加字幕#\n\n * -vf 中的 subtitles指定字幕文件位置\n\n\n\n\n8.9 添加thumbnail，文件管理时看到的封面#\n\n * -vf 中的 subtitles指定字幕文件位置\n\n\n\n\n#\n\n\n9. 下载命令#\n\n参数说明#\n\n * -i 文件，待处理源文件\n   \n   \n   \n   \n   推荐\n\n * FFmpeg\n\n * 知否","routePath":"/2024/02/24/ffmpeg-intro/","lang":"","toc":[{"text":"ffmpeg 是一个命令行音视频后期处理软件","id":"ffmpeg-是一个命令行音视频后期处理软件","depth":2,"charIndex":-1},{"text":"参数列表","id":"参数列表","depth":4,"charIndex":24},{"text":"1. 裁剪命令","id":"1-裁剪命令","depth":2,"charIndex":893},{"text":"参数说明","id":"参数说明","depth":4,"charIndex":903},{"text":"2. 合成命令","id":"2-合成命令","depth":2,"charIndex":1236},{"text":"2.1 混合合成","id":"21-混合合成","depth":3,"charIndex":1247},{"text":"参数说明","id":"参数说明-1","depth":4,"charIndex":1258},{"text":"2.2 连接合成","id":"22-连接合成","depth":3,"charIndex":1497},{"text":"参数说明","id":"参数说明-2","depth":4,"charIndex":1508},{"text":"2.3 淡出效果","id":"23-淡出效果","depth":3,"charIndex":1589},{"text":"参数说明","id":"参数说明-3","depth":4,"charIndex":1600},{"text":"2.4 合并音频","id":"24-合并音频","depth":3,"charIndex":1659},{"text":"参数说明","id":"参数说明-4","depth":4,"charIndex":1670},{"text":"2.5 合并视频","id":"25-合并视频","depth":3,"charIndex":1680},{"text":"2.6 添加水印","id":"26-添加水印","depth":3,"charIndex":1886},{"text":"2.7 抠像合并","id":"27-抠像合并","depth":3,"charIndex":1900},{"text":"3. 转换命令","id":"3-转换命令","depth":2,"charIndex":2020},{"text":"3.1 格式转换","id":"31-格式转换","depth":3,"charIndex":2031},{"text":"参数说明","id":"参数说明-5","depth":4,"charIndex":2042},{"text":"3.2 图片格式转换","id":"32-图片格式转换","depth":3,"charIndex":2141},{"text":"4. 调整命令","id":"4-调整命令","depth":2,"charIndex":2157},{"text":"4.1 音量调整","id":"41-音量调整","depth":3,"charIndex":2168},{"text":"参数说明","id":"参数说明-6","depth":4,"charIndex":2179},{"text":"4.2 升降调","id":"42-升降调","depth":3,"charIndex":2577},{"text":"4.3 音频速率调整","id":"43-音频速率调整","depth":3,"charIndex":2590},{"text":"4.4 视频速率调整","id":"44-视频速率调整","depth":3,"charIndex":2844},{"text":"4.5 添加封面","id":"45-添加封面","depth":3,"charIndex":3047},{"text":"5. 提取命令","id":"5-提取命令","depth":2,"charIndex":3256},{"text":"5.1 从视频中提取音频","id":"51-从视频中提取音频","depth":3,"charIndex":3267},{"text":"参数说明","id":"参数说明-7","depth":4,"charIndex":3282},{"text":"5.2 提取YUV","id":"52-提取yuv","depth":3,"charIndex":3874},{"text":"6. 消音命令","id":"6-消音命令","depth":2,"charIndex":3960},{"text":"参数说明","id":"参数说明-8","depth":4,"charIndex":3970},{"text":"7. 录制命令","id":"7-录制命令","depth":2,"charIndex":4033},{"text":"参数说明","id":"参数说明-9","depth":4,"charIndex":4043},{"text":"8. 视频处理","id":"8-视频处理","depth":2,"charIndex":4364},{"text":"8.1 视频转码","id":"81-视频转码","depth":3,"charIndex":4375},{"text":"8.2 抽取视频流","id":"82-抽取视频流","depth":3,"charIndex":4389},{"text":"8.2 视频压缩","id":"82-视频压缩","depth":3,"charIndex":4475},{"text":"8.2 视频速率调整","id":"82-视频速率调整","depth":3,"charIndex":4575},{"text":"8.3 视频裁剪","id":"83-视频裁剪","depth":3,"charIndex":4662},{"text":"8.4 视频翻转","id":"84-视频翻转","depth":3,"charIndex":4911},{"text":"8.5 视频截图","id":"85-视频截图","depth":3,"charIndex":4963},{"text":"8.6 去除水印","id":"86-去除水印","depth":3,"charIndex":5051},{"text":"8.7 添加水印","id":"87-添加水印","depth":3,"charIndex":5065},{"text":"8.8 添加字幕","id":"88-添加字幕","depth":3,"charIndex":5146},{"text":"8.9 添加thumbnail，文件管理时看到的封面","id":"89-添加thumbnail文件管理时看到的封面","depth":3,"charIndex":5189},{"text":"","id":"","depth":2,"charIndex":5250},{"text":"9. 下载命令","id":"9-下载命令","depth":2,"charIndex":5254},{"text":"参数说明","id":"参数说明-10","depth":4,"charIndex":5264}],"domain":"","frontmatter":{"layout":"post","title":"ffmpeg 是一个命令行音视频后期处理软件","date":"2024-02-24T16:30:00.000Z","categories":["音视频"],"tags":["ffmpeg","ffplay"]},"version":""}]