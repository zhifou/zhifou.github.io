[{"id":0,"title":"","content":"","routePath":"/404","lang":"","toc":[],"domain":"","frontmatter":{"pageType":404},"version":""},{"id":1,"title":"我就是我，不一样的烟火","content":"#","routePath":"/about/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"归档","content":"","routePath":"/blog/archives","lang":"","toc":[],"domain":"","frontmatter":{"layout":"archives","title":"归档"},"version":""},{"id":3,"title":"分类","content":"","routePath":"/blog/categories","lang":"","toc":[],"domain":"","frontmatter":{"layout":"categories","title":"分类"},"version":""},{"id":4,"title":"友情链接","content":"#\n\n欢迎光顾我的小站。如果你也想和我交换友链，可以在下方留言。\n\n * 知否知否","routePath":"/blog/flinks","lang":"","toc":[],"domain":"","frontmatter":{"pageType":"doc","title":"友情链接","sidebar":false,"outline":false},"version":""},{"id":5,"title":"标签","content":"","routePath":"/blog/tags","lang":"","toc":[],"domain":"","frontmatter":{"layout":"tags","title":"标签"},"version":""},{"id":6,"title":"引导页","content":"#\n\nTIP\n\n博客还在基于Rspress优化中，敬请期待","routePath":"/guide/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"首页","content":"","routePath":"/","lang":"","toc":[],"domain":"","frontmatter":{"layout":"home","title":"首页"},"version":""},{"id":8,"title":"","content":"Typescript在React中的类型应用，记录一下，方便自己查看。\n\n\n一、组件声明#\n\n在React中，组件的声明方式有两种：函数组件和类组件， 来看看这两种类型的组件声明时是如何定义TS类型的。\n\n\n1. 类组件#\n\n类组件的定义形式有两种：React.Component 和\nReact.PureComponent，它们都是泛型接口，接收两个参数，第一个是props类型的定义，第二个是state类型的定义，这两个参数都不是必须的，没有\n时可以省略：\n\n\n\nReact.PureComponent 也是差不多的：\n\n\n\nReact.PureComponent是有第三个参数的，它表示getSnapshotBeforeUpdate的返回值。\n\n那PureComponent和Component 的区别是什么呢？它们的主要区别是PureComponent中的shouldComponentUpdate\n是由自身进行处理的，不需要我们自己处理，所以PureComponent可以在一定程度上提升性能。\n\n有时候可能会见到这种写法，实际上和上面的效果是一样的：\n\n\n\n那如果定义时候我们不知道组件的props的类型，只有在调用时才知道组件类型，该怎么办呢？这时泛型就发挥作用了：\n\n\n\n\n2. 函数组件#\n\n通常情况下，函数组件我是这样写的：\n\n\n\n除此之外，函数类型还可以使用React.FunctionComponent来定义，也可以使用其简写React.FC，两者效果是一样的。它是一个泛型接口，可以接收\n一个参数，参数表示props的类型，这个参数不是必须的。它们就相当于这样：\n\n\n\n最终的定义形式如下：\n\n\n\n当使用这种形式来定义函数组件时，props中默认会带有children属性，它表示该组件在调用时，其内部的元素，来看一个例子，首先定义一个组件，组件中引入了Ch\nild1和Child2组件：\n\n\n\nChild1组件结构如下：\n\n\n\n我们在Child1组件中打印了children属性，它的值是一个数组，包含Child2对象和后面的文本：\n\n\n\n使用 React.FC 声明函数组件和普通声明的区别如下：\n\n * React.FC 显式地定义了返回类型，其他方式是隐式推导的；\n * React.FC 对静态属性：displayName、propTypes、defaultProps 提供了类型检查和自动补全；\n * React.FC 为 children 提供了隐式的类型（ReactElement | null）。\n\n那如果我们在定义组件时不知道props的类型，只有调用时才知道，那就还是用泛型来定义props的类型。对于使用function定义的函数组件：\n\n\n\n如果使用箭头函数定义的函数组件，直接这样调用是错误的：\n\n\n\n必须使用extends关键字来定义泛型参数才能被成功解析：\n\n\n\n\n二、React内置类型#\n\n\n1. JSX.Element#\n\n先来看看JSX.Element类型的声明：\n\n\n\n可以看到，JSX.Element是ReactElement的子类型，它没有增加属性，两者是等价的。也就是说两种类型的变量可以相互赋值。\n\nJSX.Element 可以通过执行 React.createElement 或是转译 JSX 获得：\n\n\n\n\n2. React.ReactElement#\n\nReact 的类型声明文件中提供了 React.ReactElement＜T＞，它可以让我们通过传入＜T＞来注解类组件的实例化，它在声明文件中的定义如下：\n\n\n\nReactElement是一个接口，包含type,props,key三个属性值。该类型的变量值只能是两种：null 和 ReactElement实例。\n\n通常情况下，函数组件返回ReactElement（JXS.Element）的值。\n\n\n3. React.ReactNode#\n\nReactNode类型的声明如下：\n\n\n\n可以看到，ReactNode是一个联合类型，它可以是string、number、ReactElement、null、boolean、ReactNodeArray\n。由此可知。ReactElement类型的变量可以直接赋值给ReactNode类型的变量，但反过来是不行的。\n\n类组件的 render 成员函数会返回 ReactNode 类型的值：\n\n\n\n上面的代码中，给component变量设置了类型是Mycomponent类型的react实例，这时只能给其赋值其为MyComponent的实例组件。\n\n通常情况下，类组件通过 render() 返回 ReactNode的值。\n\n\n4. CSSProperties#\n\n先来看看React的声明文件中对CSSProperties 的定义：\n\n\n\nReact.CSSProperties是React基于TypeScript定义的CSS属性类型，可以将一个方法的返回值设置为该类型：\n\n\n\n这里divStyle组件的返回值就是React.CSSProperties类型。\n\n我们还可以定义一个CSSProperties类型的变量：\n\n\n\n这个变量可以在HTML标签的style属性上使用：\n\n\n\n在React的类型声明文件中，style属性的类型如下：\n\n\n\n\n三、React Hooks#\n\n\n1. useState#\n\n默认情况下，React会为根据设置的state的初始值来自动推导state以及更新函数的类型：\n\n\n\n如果已知state 的类型，可以通过以下形式来自定义state的类型：\n\n\n\n如果初始值为null，需要显式地声明 state 的类型：\n\n\n\n如果state是一个对象，想要初始化一个空对象，可以使用断言来处理：\n\n\n\n实际上，这里将空对象{}断言为IUser接口就是欺骗了TypeScript的编译器，由于后面的代码可能会依赖这个对象，所以应该在使用前及时初始化 user\n的值，否则就会报错。\n\n下面是声明文件中 useState 的定义：\n\n\n\n可以看到，这里定义两种形式，分别是有初始值和没有初始值的形式。\n\n\n2. useEffect#\n\nuseEffect的主要作用就是处理副作用，它的第一个参数是一个函数，表示要清除副作用的操作，第二个参数是一组值，当这组值改变时，第一个参数的函数才会执行，这让\n我们可以控制何时运行函数来处理副作用：\n\n\n\n当函数的返回值不是函数或者effect函数中未定义的内容时，如下：\n\n\n\nTypeScript就会报错：\n\n\n\n来看看useEffect在类型声明文件中的定义：\n\n\n\n可以看到，useEffect的第一个参数只允许返回一个函数。\n\n\n3. useRef#\n\n当使用 useRef 时，我们可以访问一个可变的引用对象。可以将初始值传递给 useRef，它用于初始化可变 ref\n对象公开的当前属性。当我们使用useRef时，需要给其指定类型：\n\n\n\n这里给实例的类型指定为了input输入框类型。\n\n当useRef的初始值为null时，有两种创建的形式，第一种：\n\n\n\n这种形式下，ref1.current是只读的（read-only），所以当我们将它的innerText属性重新赋值时会报以下错误：\n\n\n\n那该怎么将current属性变为动态可变的，先来看看类型声明文件中 useRef 是如何定义的：\n\n\n\n这段代码的第十行的告诉我们，如果需要useRef的直接可变，就需要在泛型参数中包含'| null'，所以这就是当初始值为null的第二种定义形式：\n\n\n\n这种形式下，nameInput.current就是可写的。不过两种类型在使用时都需要做类型检查：\n\n\n\n那么问题来了，为什么第一种写法在没有操作current时没有报错呢？因为useRef在类型定义时具有多个重载声明，第一种方式就是执行的以下函数重载：\n\n\n\n从上useRef的声明中可以看到，function\nuseRef的返回值类型化是MutableRefObject，这里面的T就是参数的类型T，所以最终nameInput\n的类型就是React.MutableRefObject。\n\n注意，上面用到了HTMLInputElement类型，这是一个标签类型，这个操作就是用来访问DOM元素的。\n\n\n4. useCallback#\n\n先来看看类型声明文件中对useCallback的定义：\n\n\n\nuseCallback接收一个回调函数和一个依赖数组，只有当依赖数组中的值发生变化时才会重新执行回调函数。来看一个例子：\n\n\n\n这里我们没有给回调函数中的参数a定义类型，所以下面的调用方式都不会报错：\n\n\n\n尽管add方法的两个参数都是number类型，但是上述调用都能够用执行。所以为了更加严谨，我们需要给回调函数定义具体的类型：\n\n\n\n这时候如果再给回调函数传入字符串就会报错了：\n\n所有，需要注意，在使用useCallback时需要给回调函数的参数指定类型。\n\n\n5. useMemo#\n\n先来看看类型声明文件中对useMemo的定义：\n\n\n\nuseMemo和useCallback是非常类似的，但是它返回的是一个值，而不是函数。所以在定义useMemo时需要定义返回值的类型：\n\n\n\n如果返回值不一致，就会报错：\n\n\n\n\n6. useContext#\n\nuseContext需要提供一个上下文对象，并返回所提供的上下文的值，当提供者更新上下文对象时，引用这些上下文对象的组件就会重新渲染：\n\n\n\n在使用useContext时，会自动推断出提供的上下文对象的类型，所以并不需要我们手动设置context的类型。当前，我们也可以使用泛型来设置context的类\n型：\n\n\n\n下面是useContext在类型声明文件中的定义：\n\n\n\n\n7. useReducer#\n\n有时我们需要处理一些复杂的状态，并且可能取决于之前的状态。这时候就可以使用useReducer，它接收一个函数，这个函数会根据之前的状态来计算一个新的state\n。其语法如下：\n\n\n\n来看下面的例子：\n\n\n\n当前的状态是无法推断出来的，可以给reducer函数添加类型，通过给reducer函数定义state和action来推断 useReducer\n的类型，下面来修改上面的例子：\n\n\n\n这样，在Counter函数中就可以推断出类型。当我们试图使用一个不存在的类型时，就会报错：\n\n\n\n除此之外，还可以使用泛型的形式来实现reducer函数的类型定义：\n\n\n\n其实dispatch方法也是有类型的：\n\n\n\n可以看到，dispatch的类型是：React.Dispatch，上面示例的完整代码如下：\n\n\n\n\n四、事件处理#\n\n\n1. Event 事件类型#\n\n在开发中我们会经常在事件处理函数中使用event事件对象，比如在input框输入时实时获取输入的值；使用鼠标事件时，通过 clientX、clientY\n获取当前指针的坐标等等。\n\n我们知道，Event是一个对象，并且有很多属性，这时很多人就会把 event\n类型定义为any，这样的话TypeScript就失去了它的意义，并不会对event事件进行静态检查，如果一个键盘事件触发了下面的方法，也不会报错：\n\n\n\n由于Event事件对象中有很多的属性，所以我们也不方便把所有属性及其类型定义在一个interface中，所以React在声明文件中给我们提供了Event事件对象\n的类型声明。\n\n常见的Event 事件对象如下：\n\n * 剪切板事件对象：ClipboardEvent\n * 拖拽事件对象：DragEvent\n * 焦点事件对象：FocusEvent\n * 表单事件对象：FormEvent\n * Change事件对象：ChangeEvent\n * 键盘事件对象：KeyboardEvent\n * 鼠标事件对象：MouseEvent\n * 触摸事件对象：TouchEvent\n * 滚轮事件对象：WheelEvent\n * 动画事件对象：AnimationEvent\n * 过渡事件对象：TransitionEvent\n\n可以看到，这些Event事件对象的泛型中都会接收一个Element元素的类型，这个类型就是我们绑定这个事件的标签元素的类型，标签元素类型将在下面的第五部分介绍。\n\n来看一个简单的例子：\n\n\n\n这里就给onChange方法的事件对象定义为了FormEvent类型，并且作用的对象是一个HTMLInputElement类型的标签（input标签）\n\n可以来看下MouseEvent事件对象和ChangeEvent事件对象的类型声明，其他事件对象的声明形似也类似：\n\n\n\n在很多事件对象的声明文件中都可以看到 EventTarget\n的身影。这是因为，DOM的事件操作（监听和触发），都定义在EventTarget接口上。EventTarget 的类型声明如下：\n\n\n\n比如在change事件中，会使用的e.target来获取当前的值，它的的类型就是EventTarget。来看下面的例子：\n\n\n\n这里定义了一个input输入框，当触发onChange事件时，会调用onSourceChange方法，该方法的参数e的类型就是：React.ChangeEven\nt，而e.target的类型就是EventTarget：\n\n\n\n再来看一个例子：\n\n\n\n这点代码中，点击某个盒子，就将它设置为当前的盒子，方便执行其他操作。当鼠标点击盒子时，会触发handleChangeCurren方法，该方法有两个参数，第二个参\n数是event对象，在方法中执行了e.stopPropagation();是为了阻止冒泡事件，这里的stopPropagation()实际上并不是鼠标事件Mou\nseEvent的属性，它是合成事件上的属性，来看看声明文件中的定义：\n\n\n\n可以看到，这里的stopPropagation()是一层层的继承来的，最终来自于BaseSyntheticEvent合成事件类型。原生的事件集合Syntheti\ncEvent就是继承自合成时间类型。SyntheticEvent泛型接口接收当前的元素类型和事件类型，如果不介意这两个参数的类型，完全可以这样写：\n\n\n\n\n2. 事件处理函数类型#\n\n说完事件对象类型，再来看看事件处理函数的类型。React也为我们提供了贴心的提供了事件处理函数的类型声明，来看看所有的事件处理函数的类型声明：\n\n\n\n这里面的T的类型也都是Element，指的是触发该事件的HTML标签元素的类型，下面第五部分会介绍。\n\nEventHandler会接收一个E，它表示事件处理函数中 Event 对象的类型。bivarianceHack 是事件处理函数的类型定义，函数接收一个\nEvent 对象，并且其类型为接收到的泛型变量 E 的类型, 返回值为 void。\n\n还看上面的那个例子：\n\n\n\n这里给onChange方法定义了方法的类型，它是一个ChangeEventHandler的类型，并且作用的对象是一个HTMLImnputElement类型的标签\n（input标签）。\n\n\n五、HTML标签类型#\n\n\n1. 常见标签类型#\n\n在项目的依赖文件中可以找到HTML标签相关的类型声明文件：\n\n\n\n所有的HTML标签的类型都被定义在 intrinsicElements 接口中，常见的标签及其类型如下：\n\n\n\n那什么时候会使用到标签类型呢，上面第四部分的Event事件类型和事件处理函数类型中都使用到了标签的类型。上面的很多的类型都需要传入一个ELement类型的泛型参\n数，这个泛型参数就是对应的标签类型值，可以根据标签来选择对应的标签类型。这些类型都继承自HTMLElement类型，如果使用时对类型类型要求不高，可以直接写HT\nMLELement。比如下面的例子：\n\n\n\n其实，在直接操作DOM时也会用到标签类型，虽然我们现在通常会使用框架来开发，但是有时候也避免不了直接操作DOM。比如我在工作中，项目中的某一部分组件是通过npm\n来引入的其他组的组件，而在很多时候，我有需要动态的去个性化这个组件的样式，最直接的办法就是通过原生JavaScript获取到DOM元素，来进行样式的修改，这时候\n就会用到标签类型。\n\n来看下面的例子：\n\n\n\n这是我最近写的一段代码（略微删改），在第一页有个add-ele元素的时候就删除它。这里我们将item.firstChild断言成了HTMLDivElement类\n型，如果不断言，item.firstChild的类型就是ChildNode，而ChildNode类型中是不存在classList属性的，所以就就会报错，当我们把\n他断言成HTMLDivElement类型时，就不会报错了。很多时候，标签类型可以和断言（as）一起使用。\n\n后面在removeChild时又使用了as断言，为什么呢？item.firstChild不是已经自动识别为ChildNode类型了吗？因为TS会认为，我们可能不\n能获取到类名为paper的元素，所以item.firstChild的类型就被推断为ChildNode |\nnull，我们有时候比TS更懂我们定义的元素，知道页面一定存在paper 元素，所以可以直接将item.firstChild断言成ChildNode类型。\n\n\n2. 标签属性类型#\n\n众所周知，每个HTML标签都有自己的属性，比如Input框就有value、width、placeholder、max-length等属性，下面是Input框的属\n性类型定义：\n\n\n\n如果我们需要直接操作DOM，就可能会用到元素属性类型，常见的元素属性类型如下：\n\n * HTML属性类型：HTMLAttributes\n * 按钮属性类型：ButtonHTMLAttributes\n * 表单属性类型：FormHTMLAttributes\n * 图片属性类型：ImgHTMLAttributes\n * 输入框属性类型：InputHTMLAttributes\n * 链接属性类型：LinkHTMLAttributes\n * meta属性类型：MetaHTMLAttributes\n * 选择框属性类型：SelectHTMLAttributes\n * 表格属性类型：TableHTMLAttributes\n * 输入区属性类型：TextareaHTMLAttributes\n * 视频属性类型：VideoHTMLAttributes\n * SVG属性类型：SVGAttributes\n * WebView属性类型：WebViewHTMLAttributes\n\n一般情况下，我们是很少需要在项目中显式的去定义标签属性的类型。如果子级去封装组件库的话，这些属性就能发挥它们的作用了。来看例子（来源于网络，仅供学习）：\n\n\n\n这段代码就是用来封装一个buttom按钮，在button的基础上添加了一些自定义属性，比如上面将button的类型使用交叉类型（&）获得自定义属性和原生\nbutton 属性 ：\n\n\n\n可以看到，标签属性类型在封装组件库时还是很有用的，更多用途可以自己探索~\n\n\n六、工具泛型#\n\n在项目中使用一些工具泛型可以提高我们的开发效率，少写很多类型定义。下面来看看有哪些常见的工具泛型，以及其使用方式。\n\n\n1. Partial#\n\nPartial 作用是将传入的属性变为可选项。适用于对类型结构不明确的情况。它使用了两个关键字：keyof和in，先来看看他们都是什么含义。keyof\n可以用来取得接口的所有 key 值：\n\n\n\nin关键字可以遍历枚举类型,：\n\n\n\nkeyof 可以产生联合类型, in 可以遍历枚举类型, 所以经常一起使用, 下面是Partial工具泛型的定义：\n\n\n\n这里，keyof T 获取 T 所有属性名, 然后使用 in 进行遍历, 将值赋给 P, 最后 T[P] 取得相应属性的值。中间的?就用来将属性设置为可选。\n\n使用示例如下：\n\n\n\n\n2. Required#\n\nRequired 的作用是将传入的属性变为必选项，和上面的工具泛型恰好相反，其声明如下：\n\n\n\n可以看到，这里使用-?将属性设置为必选，可以理解为减去问号。使用形式和上面的Partial差不多：\n\n\n\n\n3. Readonly#\n\n将T类型的所有属性设置为只读（readonly），构造出来类型的属性不能被再次赋值。Readonly的声明形式如下：\n\n\n\n使用示例如下：\n\n\n\n可以看到，通过 Readonly将IPerson的属性转化成了只读，不能再进行赋值操作。\n\n\n4. Pick#\n\n从T类型中挑选部分属性K来构造新的类型。它的声明形式如下：\n\n\n\n使用示例如下：\n\n\n\n\n5. Record#\n\nRecord 用来构造一个类型，其属性名的类型为K，属性值的类型为T。这个工具泛型可用来将某个类型的属性映射到另一个类型上，下面是其声明形式：\n\n\n\n使用示例如下：\n\n\n\n\n6. Exclude#\n\nExclude 就是从一个联合类型中排除掉属于另一个联合类型的子集，下面是其声明的形式：\n\n\n\n使用示例如下：\n\n\n\n\n7. Omit#\n\n上面的Pick 和 Exclude 都是最基础基础的工具泛型，很多时候用 Pick 或者 Exclude 还不如直接写类型更直接。而 Omit\n就基于这两个来做的一个更抽象的封装，它允许从一个对象中剔除若干个属性，剩下的就是需要的新类型。下面是它的声明形式：\n\n\n\n使用示例如下：\n\n\n\n\n8. ReturnType#\n\nReturnType会返回函数返回值的类型，其声明形式如下：\n\n\n\n使用示例如下：\n\n\n\n这里使用 typeof 是为了获取 foo 的函数签名，等价于 (type: any) => boolean。\n\n\n七、其他#\n\n\n1. import React#\n\n在React项目中使用TypeScript时，普通组件文件后缀为.tsx，公共方法文件后缀为.ts。在. tsx 文件中导入 React 的方式如下：\n\n\n\n这是一种面向未来的导入方式，如果想在项目中使用以下导入方式：\n\n\n\n就需要在tsconfig.json配置文件中进行如下配置：\n\n\n\n\n2. Types or Interfaces？#\n\n我们可以使用types或者Interfaces来定义类型吗，那么该如何选择他俩呢？建议如下：\n\n * 在定义公共 API 时(比如编辑一个库）使用 interface，这样可以方便使用者继承接口，这样允许使用者通过声明合并来扩展它们；\n * 在定义组件属性（Props）和状态（State）时，建议使用 type，因为 type 的约束性更强。\n\ninterface 和 type 在 ts 中是两个不同的概念，但在 React 大部分使用的 case 中，interface 和 type\n可以达到相同的功能效果，type 和 interface 最大的区别是：type 类型不能二次编辑，而 interface 可以随时扩展：\n\n\n\ntype对于联合类型是很有用的，比如：type Type = TypeA | TypeB。而interface更适合声明字典类行，然后定义或者扩展它。\n\n\n3. 懒加载类型#\n\n如果我们想在React router中使用懒加载，React也为我们提供了懒加载方法的类型，来看下面的例子：\n\n\n\n下面是懒加载类型和lazy方法在声明文件中的定义：\n\n\n\n\n4. 类型断言#\n\n类型断言（Type\nAssertion）可以用来手动指定一个值的类型。在React项目中，断言还是很有用的，。有时候推断出来的类型并不是真正的类型，很多时候我们可能会比TS更懂我们\n的代码，所以可以使用断言（使用as关键字）来定义一个值得类型。\n\n来看下面的例子：\n\n\n\n当TypeScript不确定一个联合类型的变量到底是哪个类型时，就只能访问此联合类型的所有类型里共有的属性或方法，所以现在加了对参数target和返回值的类型定\n义之后就会报错。这时就可以使用断言，将target的类型断言成string类型：\n\n\n\n需要注意，类型断言并不是类型转换，断言成一个联合类型中不存在的类型是不允许的。\n\n再来看一个例子，在调用一个方法时传入参数：这里就提示我们这个参数可能是u\nndefined，而通过业务知道这个值是一定存在的，所以就可以将它断言成数字：data?.subjectId as number\n\n除此之外，上面所说的标签类型、组件类型、时间类型都可以使用断言来指定给一些数据，还是要根据实际的业务场景来使用。\n\n感悟：使用类型断言真的能解决项目中的很多报错~\n\n\n5. 枚举类型#\n\n枚举类型在项目中的作用也是不可忽视的，使用枚举类型可以让代码的扩展性更好，当我想更改某属性值时，无需去全局更改这个属性，只要更改枚举中的值即可。通常情况下，最好\n新建一个文件专门来定义枚举值，便于引用。\n\n关于在React项目中如何优雅的使用TypeScript就先介绍这么多，后面有新的内容会再分享给大家。如果觉得不错就点个赞吧！","routePath":"/2024/02/05/typescript-react-type/","lang":"","toc":[{"text":"一、组件声明","id":"一组件声明","depth":2,"charIndex":37},{"text":"1. 类组件","id":"1-类组件","depth":3,"charIndex":103},{"text":"2. 函数组件","id":"2-函数组件","depth":3,"charIndex":544},{"text":"二、React内置类型","id":"二react内置类型","depth":2,"charIndex":1211},{"text":"1. JSX.Element","id":"1-jsxelement","depth":3,"charIndex":1226},{"text":"2. React.ReactElement","id":"2-reactreactelement","depth":3,"charIndex":1393},{"text":"3. React.ReactNode","id":"3-reactreactnode","depth":3,"charIndex":1618},{"text":"4. CSSProperties","id":"4-cssproperties","depth":3,"charIndex":1951},{"text":"三、React Hooks","id":"三react-hooks","depth":2,"charIndex":2214},{"text":"1. useState","id":"1-usestate","depth":3,"charIndex":2231},{"text":"2. useEffect","id":"2-useeffect","depth":3,"charIndex":2556},{"text":"3. useRef","id":"3-useref","depth":3,"charIndex":2792},{"text":"4. useCallback","id":"4-usecallback","depth":3,"charIndex":3458},{"text":"5. useMemo","id":"5-usememo","depth":3,"charIndex":3741},{"text":"6. useContext","id":"6-usecontext","depth":3,"charIndex":3871},{"text":"7. useReducer","id":"7-usereducer","depth":3,"charIndex":4075},{"text":"四、事件处理","id":"四事件处理","depth":2,"charIndex":4445},{"text":"1. Event 事件类型","id":"1-event-事件类型","depth":3,"charIndex":4455},{"text":"2. 事件处理函数类型","id":"2-事件处理函数类型","depth":3,"charIndex":5917},{"text":"五、HTML标签类型","id":"五html标签类型","depth":2,"charIndex":6286},{"text":"1. 常见标签类型","id":"1-常见标签类型","depth":3,"charIndex":6300},{"text":"2. 标签属性类型","id":"2-标签属性类型","depth":3,"charIndex":7200},{"text":"六、工具泛型","id":"六工具泛型","depth":2,"charIndex":7950},{"text":"1. Partial","id":"1-partial","depth":3,"charIndex":8019},{"text":"2. Required","id":"2-required","depth":3,"charIndex":8302},{"text":"3. Readonly","id":"3-readonly","depth":3,"charIndex":8418},{"text":"4. Pick<T, K extends keyof T>","id":"4-pickt-k-extends-keyof-t","depth":3,"charIndex":-1},{"text":"5. Record<K extends keyof any, T>","id":"5-recordk-extends-keyof-any-t","depth":3,"charIndex":-1},{"text":"6. Exclude<T, U>","id":"6-excludet-u","depth":3,"charIndex":-1},{"text":"7. Omit<T, K extends keyof any>","id":"7-omitt-k-extends-keyof-any","depth":3,"charIndex":-1},{"text":"8. ReturnType","id":"8-returntype","depth":3,"charIndex":8934},{"text":"七、其他","id":"七其他","depth":2,"charIndex":9053},{"text":"1. import React","id":"1-import-react","depth":3,"charIndex":9061},{"text":"2. Types or Interfaces？","id":"2-types-or-interfaces","depth":3,"charIndex":9226},{"text":"3. 懒加载类型","id":"3-懒加载类型","depth":3,"charIndex":9649},{"text":"4. 类型断言","id":"4-类型断言","depth":3,"charIndex":9748},{"text":"5. 枚举类型","id":"5-枚举类型","depth":3,"charIndex":10247}],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"ffmpeg 是一个命令行音视频后期处理软件","content":"ffmpeg 是一个命令行音视频后期处理软件#\n\n参数列表#\n\n * -i input_file：指定输入文件的路径和名称。示例：-i input.mp4\n * -ss position：指定从输入文件的哪个时间位置开始处理，格式为 HH:MM:SS.xxx（小时:分钟:秒.毫秒）。示例：-ss\n   00:01:30.500 表示从 1 分 30.5 秒开始处理。\n * -t duration：指定处理的持续时间，格式为 HH:MM:SS.xxx（小时:分钟:秒.毫秒）。示例：-t 00:00:45 表示处理 45\n   秒的内容。\n * -vf filtergraph：指定视频过滤器图形，用于对视频进行各种处理，如调整大小、裁剪、旋转、滤镜等。示例：-vf \"scale=640:480\"\n   表示将视频调整为 640x480 的大小。\n * -af filtergraph：指定音频过滤器图形，用于对音频进行各种处理，如音频增益、降噪、混音等。示例：-af \"volume=2.0\"\n   表示将音频增益调整为原来的 2 倍。\n * -c:v codec：指定视频编解码器。示例：-c:v libx264 表示使用 libx264 编码器进行视频编码。\n * -c:a codec：指定音频编解码器。示例：-c:a aac 表示使用 AAC 编码器进行音频编码。\n * -b:v bitrate：指定视频的比特率，即视频的质量。较高的比特率通常意味着更好的视频质量，但文件大小也会增加。示例：-b:v 1000k\n   表示视频比特率为 1000kbps。\n * -b:a bitrate：指定音频的比特率，即音频的质量。较高的比特率通常意味着更好的音频质量，但文件大小也会增加。示例：-b:a 128k\n   表示音频比特率为 128kbps。\n * -r framerate：指定视频的帧率，即每秒播放的画面数量。较高的帧率可以获得更流畅的视频，但也会增加文件大小。示例：-r 30 表示视频帧率为 30\n   帧每秒。\n * -y 不询问直接覆盖原有的同名文件\n\n\n1. 裁剪命令#\n\n参数说明#\n\n * -i input_file：指定输入文件的路径和名称。示例：-i input.mp3\n\n * -ss position：指定从输入文件的哪个时间位置开始处理，格式为 HH:MM:SS.xxx（小时:分钟:秒.毫秒）。示例：-ss\n   00:01:30.500 表示从 1 分 30.5 秒开始处理。\n\n * -t duration：指定处理的持续时间，格式为 HH:MM:SS.xxx（小时:分钟:秒.毫秒）。示例：-t 00:00:45 表示处理 45\n   秒的内容。\n\n * -to 终止点时间\n\n * -c copy 表示不改变音频和视频的编码格式，直接拷贝，提升效率\n\n * output.mp3 为处理结果文件\n   \n   \n\n\n2. 合成命令#\n\n\n2.1 混合合成#\n\n参数说明#\n\n * -i 文件 1.mp3 和 2.mp3 为待合成的两个源文件\n\n * -filter_complex 过滤器参数\n\n * amix=inputs 配置输入的整体样本数\n\n * duration，first：长度取决于第一个文件，longest：长度取决于时间最长文件，shortest：长度取决于时间最短文件\n\n * dropout_transition：输入流结束时用于体积重新规范化的过渡时间\n\n * -f mp3 设置导出文件格式\n   \n   \n\n\n2.2 连接合成#\n\n参数说明#\n\n * concat 合并文件指令\n   \n   \n\n * 使用txt文件集合concat合并，视频合并使用这个list合并方式\n   \n   \n\n\n2.3 淡出效果#\n\n参数说明#\n\n * afade 淡入淡出指令\n\n * 从 st 秒开始，经过 d 秒钟的淡出效果\n   \n   \n\n\n2.4 合并音频#\n\n参数说明#\n\n\n\n\n2.5 合并视频#\n\n首先需要将原视频的声音删除。这里的文件名需要加上英文引号，如果不加的话，会提示No such file or directory。\n\n\n\n然后将无声视频和音频融合\n\n\n\n即可获得消去人声的视频。但笔者口语不好，觉得原视频的语速有些快了，故又调整了视频倍速为0.8倍速。\n\n\n\n这条指令同时调整视频倍速和音频倍速，setpts=(倍速的倒数)*PTS[v]，atempo=(倍速)[a]\n\n\n2.6 添加水印#\n\n\n\n\n2.7 抠像合并#\n\n * -vf filtergraph：指定视频过滤器图形，用于对视频进行各种处理，如调整大小、裁剪、旋转、滤镜等。示例：-vf \"scale=640:480\"\n   表示将视频调整为 640x480 的大小。\n\n\n\n\n3. 转换命令#\n\n\n3.1 格式转换#\n\n参数说明#\n\n * -i 文件，a.mp3 为待处理源文件\n\n * -ar 音频抽样率\n\n * -ac 音频Channel数\n\n * -f 强制输出格式 例如mp3, wav等\n   \n   \n\n\n3.2 图片格式转换#\n\n\n\n\n4. 调整命令#\n\n\n4.1 音量调整#\n\n参数说明#\n\n * -i 文件，input.mp3 为待处理源文件\n\n * -af filtergraph：指定音频过滤器图形，用于对音频进行各种处理，如音频增益、降噪、混音等。示例：-af \"volume=2.0\"\n   表示将音频增益调整为原来的 2 倍。\n   \n   \n   \n   dB的换算公式 1.1 dB = 1.1 倍，2 dB = 1.25倍，3 dB = 1.4倍，6 dB = 2 倍，10 dB = 3 倍，20 dB\n   = 10 倍，30 dB = 30 倍。其它就可以用上述数值换算，并不困难。(反过来 – 6 dB 就是 1/2 = 0.5)\n   2.在换算时要把握一个原则，dB数值的相加 等于 倍数的相乘。 例如：40 dB = 20dB + 20 dB = 10 * 10 = 100 倍\n   -20dB谱宽就是信号衰减到十分之一时的频谱带宽。\n\n\n4.2 升降调#\n\n\n\n\n4.3 音频速率调整#\n\n改变音频速率最简单的方法是直接调整音频的采样率，但是与此同时，这种方法会改变音频的音色。目前一般采用对原音进行重采样，差值等方法来实现。下面这行命令的倍率调整范\n围为0.5到2。\n\n\n\n如果想要再快的话，需要更改命令，通过将多个atempo过滤器串接在一起来绕过这个限制。\n\n\n\n将对输入文件 test_cut.mp3 应用音频效果，包括加速 2 倍(atempo)、高通滤波器(highpass)和低通滤波器(lowpass)，并保存为\ntest_cut_ahl.mp3\n\n\n\n\n4.4 视频速率调整#\n\n改变视频的播放速率是通过修改视频的表示时间戳（PTS）来实现的。举个简单的例子，如果在时间戳1和2处显示两个连续帧，我们想要加快视频速度，那么这两个时间戳需要分\n别变为0.5和1。因此，我们必须把他们乘以0.5。\n\n\n\n对视频进行加速时，为了不丢帧，可以利用-r 参数指定输出的fps。 一般来说，视频倍速还需要将视频中的音频也一同倍速，通过混合的过滤图实现，命令如下，\n\n\n\n\n4.5 添加封面#\n\n从 test.mp3 音频文件中提取音频流，并从 test.jpeg 图像文件中提取封面图像。然后，它将使用-map\n选项将音频流和封面图像流映射到输出文件。-c copy 选项用于直接复制音频流和封面图像流，而不进行重新编码。-id3v2_version 3 选项用于设置\nID3 标签版本为 3，以确保兼容性。-metadata:s:v 选项用于指定封面图像的元数据，如标题和注释。\n\n\n\n\n5. 提取命令#\n\n\n5.1 从视频中提取音频#\n\n参数说明#\n\n * -map 提取视频-音频流的序号\n * -b:a 码率 kb/s\n * -f 强制输出格式 例如mp3, wav等\n * -vn 表示去除视频流，v 代表视频，n 代表 no 也就是无视频的意思\n * acodec: 指定音频编码器，copy 指明只拷贝，不做编解码\n\n\n\n查看视频，包含的视频流、音频流如下： encoder : libebml v1.2.3 + libmatroska v1.3.0 Duration:\n01:42:13.09, start: 0.000000, bitrate: 2954 kb/s Stream #0:0: Video: h264\n(High), yuv420p, 1024x576 [SAR 1:1 DAR 16:9], 23.98 fps Stream #0:1(eng): Audio:\nac3, 48000 Hz, 384 kb/s (default) title : 英语 Stream #0:2(chi): Audio: ac3, 48000\nHz, 384 kb/s title : 台配 Stream #0:3(chi): Audio: ac3, 48000 Hz, 384 kb/s title :\n粤语\n\n查看原音视频文件音轨频率\n\n\n\n命令执行后找到音轨的Stream，频率为48000Hz；\n\n\n\n\n5.2 提取YUV#\n\n * -c:v rawvideo 指定将视频转成原始数据\n * -pixel_format yuv420p 指定转换格式为 yuv420p\n\n\n\n\n6. 消音命令#\n\n参数说明#\n\n * -i 文件，input.mp3 为待处理源文件\n\n * -ac 音频Channel数\n   \n   \n\n\n7. 录制命令#\n\n参数说明#\n\n * -f avfoundation 输入设备，从 Mac 的音频输入设备（通常是麦克风）录制音频\n\n * -i 指定从哪儿采集数据，它是一个文件索引号。在我的电脑上，1 代表桌面（可以通过上面的命令查询设备索引号）\n\n * -r 指定帧率。按 ffmpeg 官方文档说-r 与-framerate 作用相同，但实际测试时发现不同。-framerate 用于限制输入，而-r\n   用于限制输出。\n\n * -framerate 限制视频的采集帧率。这个必须要根据提示要求进行设置，如果不设置就会报错。\n\n * \":0\" 参数表示默认的音频输入设备\n\n * \"1:0\" 参数表示\"视频输入设备:音频输入设备\"\n   \n   \n\n\n8. 视频处理#\n\n\n8.1 视频转码#\n\n\n\n\n8.2 抽取视频流#\n\n * vcodec: 指定视频编码器，copy 指明只拷贝，不做编解码。\n * an: a 代表视频，n 代表 no 也就是无音频的意思。\n\n\n\n\n8.2 视频压缩#\n\n * -b:v 视频码率设置\n * -vf scale 指定使用简单过滤器 scale，iw/2:-1 中的 iw 指定按整型取视频的宽度。-1表示高度随宽度一起变化。\n\n\n\n\n8.2 视频速率调整#\n\n * -vf scale 指定使用简单过滤器 scale，iw/2:-1 中的 iw 指定按整型取视频的宽度。-1表示高度随宽度一起变化。\n\n\n\n\n8.3 视频裁剪#\n\n * crop 格式：crop=w:h:x :y\n   \n   * w: 输出的宽度。可以使用 in_w 表式输入视频的宽度。\n   * h: 输出的高度。可以使用 in_h 表式输入视频的高度。\n   * x : X 坐标\n   * y : Y 坐标\n   \n   如果 x 和 y 设置为 0,说明从左上角开始裁剪。如果不写是从中心点裁剪。\n\n * -strict -2 指明音频使有 AAC\n\n * -f hls 转成 m3u8 格式\n\n * -vf 视频过滤\n\n\n\n\n8.4 视频翻转#\n\n * hflip 水平翻转\n * 如果要修改为垂直翻转可以用 vflip\n\n\n\n\n8.5 视频截图#\n\n * 从上面的 out.mp4 中提取第 10 秒的视频帧，并将其保存为输出文件 output.jpg。参数-vframes 1表示只提取一帧。\n\n\n\n\n8.6 去除水印#\n\n\n\n\n8.7 添加水印#\n\n * -vf 中的 movie 指定 logo 位置。scale 指定 logo 大小。overlay 指定 logo 摆放的位置\n\n\n\n\n8.8 添加字幕#\n\n * -vf 中的 subtitles指定字幕文件位置\n\n\n\n\n8.9 添加thumbnail，文件管理时看到的封面#\n\n * -vf 中的 subtitles指定字幕文件位置\n\n\n\n\n#\n\n\n9. 下载命令#\n\n参数说明#\n\n * -i 文件，待处理源文件\n   \n   \n   \n   \n   推荐\n\n * FFmpeg\n\n * 知否","routePath":"/2024/02/24/ffmpeg-intro/","lang":"","toc":[{"text":"ffmpeg 是一个命令行音视频后期处理软件","id":"ffmpeg-是一个命令行音视频后期处理软件","depth":2,"charIndex":-1},{"text":"参数列表","id":"参数列表","depth":4,"charIndex":24},{"text":"1. 裁剪命令","id":"1-裁剪命令","depth":2,"charIndex":893},{"text":"参数说明","id":"参数说明","depth":4,"charIndex":903},{"text":"2. 合成命令","id":"2-合成命令","depth":2,"charIndex":1236},{"text":"2.1 混合合成","id":"21-混合合成","depth":3,"charIndex":1247},{"text":"参数说明","id":"参数说明-1","depth":4,"charIndex":1258},{"text":"2.2 连接合成","id":"22-连接合成","depth":3,"charIndex":1497},{"text":"参数说明","id":"参数说明-2","depth":4,"charIndex":1508},{"text":"2.3 淡出效果","id":"23-淡出效果","depth":3,"charIndex":1589},{"text":"参数说明","id":"参数说明-3","depth":4,"charIndex":1600},{"text":"2.4 合并音频","id":"24-合并音频","depth":3,"charIndex":1659},{"text":"参数说明","id":"参数说明-4","depth":4,"charIndex":1670},{"text":"2.5 合并视频","id":"25-合并视频","depth":3,"charIndex":1680},{"text":"2.6 添加水印","id":"26-添加水印","depth":3,"charIndex":1886},{"text":"2.7 抠像合并","id":"27-抠像合并","depth":3,"charIndex":1900},{"text":"3. 转换命令","id":"3-转换命令","depth":2,"charIndex":2020},{"text":"3.1 格式转换","id":"31-格式转换","depth":3,"charIndex":2031},{"text":"参数说明","id":"参数说明-5","depth":4,"charIndex":2042},{"text":"3.2 图片格式转换","id":"32-图片格式转换","depth":3,"charIndex":2141},{"text":"4. 调整命令","id":"4-调整命令","depth":2,"charIndex":2157},{"text":"4.1 音量调整","id":"41-音量调整","depth":3,"charIndex":2168},{"text":"参数说明","id":"参数说明-6","depth":4,"charIndex":2179},{"text":"4.2 升降调","id":"42-升降调","depth":3,"charIndex":2577},{"text":"4.3 音频速率调整","id":"43-音频速率调整","depth":3,"charIndex":2590},{"text":"4.4 视频速率调整","id":"44-视频速率调整","depth":3,"charIndex":2844},{"text":"4.5 添加封面","id":"45-添加封面","depth":3,"charIndex":3047},{"text":"5. 提取命令","id":"5-提取命令","depth":2,"charIndex":3256},{"text":"5.1 从视频中提取音频","id":"51-从视频中提取音频","depth":3,"charIndex":3267},{"text":"参数说明","id":"参数说明-7","depth":4,"charIndex":3282},{"text":"5.2 提取YUV","id":"52-提取yuv","depth":3,"charIndex":3874},{"text":"6. 消音命令","id":"6-消音命令","depth":2,"charIndex":3960},{"text":"参数说明","id":"参数说明-8","depth":4,"charIndex":3970},{"text":"7. 录制命令","id":"7-录制命令","depth":2,"charIndex":4033},{"text":"参数说明","id":"参数说明-9","depth":4,"charIndex":4043},{"text":"8. 视频处理","id":"8-视频处理","depth":2,"charIndex":4364},{"text":"8.1 视频转码","id":"81-视频转码","depth":3,"charIndex":4375},{"text":"8.2 抽取视频流","id":"82-抽取视频流","depth":3,"charIndex":4389},{"text":"8.2 视频压缩","id":"82-视频压缩","depth":3,"charIndex":4475},{"text":"8.2 视频速率调整","id":"82-视频速率调整","depth":3,"charIndex":4575},{"text":"8.3 视频裁剪","id":"83-视频裁剪","depth":3,"charIndex":4662},{"text":"8.4 视频翻转","id":"84-视频翻转","depth":3,"charIndex":4911},{"text":"8.5 视频截图","id":"85-视频截图","depth":3,"charIndex":4963},{"text":"8.6 去除水印","id":"86-去除水印","depth":3,"charIndex":5051},{"text":"8.7 添加水印","id":"87-添加水印","depth":3,"charIndex":5065},{"text":"8.8 添加字幕","id":"88-添加字幕","depth":3,"charIndex":5146},{"text":"8.9 添加thumbnail，文件管理时看到的封面","id":"89-添加thumbnail文件管理时看到的封面","depth":3,"charIndex":5189},{"text":"","id":"","depth":2,"charIndex":5250},{"text":"9. 下载命令","id":"9-下载命令","depth":2,"charIndex":5254},{"text":"参数说明","id":"参数说明-10","depth":4,"charIndex":5264}],"domain":"","frontmatter":{"layout":"post","title":"ffmpeg 是一个命令行音视频后期处理软件","date":"2024-02-24T16:30:00.000Z","categories":["音视频"],"tags":["ffmpeg","ffplay"]},"version":""}]